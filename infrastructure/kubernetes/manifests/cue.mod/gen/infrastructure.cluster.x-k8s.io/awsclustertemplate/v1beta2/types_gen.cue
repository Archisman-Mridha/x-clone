// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f /tmp/kue/cluster-api-provider-aws/config/crd/bases/infrastructure.cluster.x-k8s.io_awsclustertemplates.yaml

package v1beta2

import "strings"

// AWSClusterTemplate is the schema for Amazon EC2 based
// Kubernetes Cluster Templates.
#AWSClusterTemplate: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "infrastructure.cluster.x-k8s.io/v1beta2"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "AWSClusterTemplate"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// AWSClusterTemplateSpec defines the desired state of
	// AWSClusterTemplate.
	spec!: #AWSClusterTemplateSpec
}
#AWSClusterTemplateSpec: {
	// AWSClusterTemplateResource defines the desired state of
	// AWSClusterTemplateResource.
	template!: {
		// Standard object's metadata.
		// More info:
		// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
		metadata?: {
			// annotations is an unstructured key value map stored with a
			// resource that may be
			// set by external tools to store and retrieve arbitrary metadata.
			// They are not
			// queryable and should be preserved when modifying objects.
			// More info: http://kubernetes.io/docs/user-guide/annotations
			annotations?: {
				[string]: string
			}

			// labels is a map of string keys and values that can be used to
			// organize and categorize
			// (scope and select) objects. May match selectors of replication
			// controllers
			// and services.
			// More info: http://kubernetes.io/docs/user-guide/labels
			labels?: {
				[string]: string
			}
		}

		// AWSClusterSpec defines the desired state of an EC2-based
		// Kubernetes cluster.
		spec!: {
			// AdditionalTags is an optional set of tags to add to AWS
			// resources managed by the AWS provider, in addition to the
			// ones added by default.
			additionalTags?: {
				[string]: string
			}

			// Bastion contains options to configure the bastion host.
			bastion?: {
				// AllowedCIDRBlocks is a list of CIDR blocks allowed to access
				// the bastion host.
				// They are set as ingress rules for the Bastion host's Security
				// Group (defaults to 0.0.0.0/0).
				allowedCIDRBlocks?: [...string]

				// AMI will use the specified AMI to boot the bastion. If not
				// specified,
				// the AMI will default to one picked out in public space.
				ami?: string

				// DisableIngressRules will ensure there are no Ingress rules in
				// the bastion host's security group.
				// Requires AllowedCIDRBlocks to be empty.
				disableIngressRules?: bool

				// Enabled allows this provider to create a bastion host instance
				// with a public ip to access the VPC private network.
				enabled?: bool

				// InstanceType will use the specified instance type for the
				// bastion. If not specified,
				// Cluster API Provider AWS will use t3.micro for all regions
				// except us-east-1, where t2.micro
				// will be the default.
				instanceType?: string
			}

			// ControlPlaneEndpoint represents the endpoint used to
			// communicate with the control plane.
			controlPlaneEndpoint?: {
				// host is the hostname on which the API server is serving.
				host!: strings.MaxRunes(512)

				// port is the port on which the API server is serving.
				port!: int32
			}

			// ControlPlaneLoadBalancer is optional configuration for
			// customizing control plane behavior.
			controlPlaneLoadBalancer?: {
				// AdditionalListeners sets the additional listeners for the
				// control plane load balancer.
				// This is only applicable to Network Load Balancer (NLB) types
				// for the time being.
				additionalListeners?: [...{
					// HealthCheck sets the optional custom health check configuration
					// to the API target group.
					healthCheck?: {
						// The approximate amount of time, in seconds, between health
						// checks of an individual
						// target.
						intervalSeconds?: uint & >=5 & <=300

						// The destination for health checks on the targets when using the
						// protocol HTTP or HTTPS,
						// otherwise the path will be ignored.
						path?: string

						// The port the load balancer uses when performing health checks
						// for additional target groups. When
						// not specified this value will be set for the same of listener
						// port.
						port?: string

						// The protocol to use to health check connect with the target.
						// When not specified the Protocol
						// will be the same of the listener.
						protocol?: "TCP" | "HTTP" | "HTTPS"

						// The number of consecutive health check successes required
						// before considering
						// a target healthy.
						thresholdCount?: uint & >=2 & <=10

						// The amount of time, in seconds, during which no response from a
						// target means
						// a failed health check.
						timeoutSeconds?: uint & >=2 & <=120

						// The number of consecutive health check failures required before
						// considering
						// a target unhealthy.
						unhealthyThresholdCount?: uint & >=2 & <=10
					}

					// Port sets the port for the additional listener.
					port!: uint16 & >=1

					// Protocol sets the protocol for the additional listener.
					// Currently only TCP is supported.
					protocol?: "TCP"
				}]

				// AdditionalSecurityGroups sets the security groups used by the
				// load balancer. Expected to be security group IDs
				// This is optional - if not provided new security groups will be
				// created for the load balancer
				additionalSecurityGroups?: [...string]

				// CrossZoneLoadBalancing enables the classic ELB cross
				// availability zone balancing.
				//
				// With cross-zone load balancing, each load balancer node for
				// your Classic Load Balancer
				// distributes requests evenly across the registered instances in
				// all enabled Availability Zones.
				// If cross-zone load balancing is disabled, each load balancer
				// node distributes requests evenly across
				// the registered instances in its Availability Zone only.
				//
				// Defaults to false.
				crossZoneLoadBalancing?: bool

				// DisableHostsRewrite disabled the hair pinning issue solution
				// that adds the NLB's address as 127.0.0.1 to the hosts
				// file of each instance. This is by default, false.
				disableHostsRewrite?: bool

				// HealthCheck sets custom health check configuration to the API
				// target group.
				healthCheck?: {
					// The approximate amount of time, in seconds, between health
					// checks of an individual
					// target.
					intervalSeconds?: uint & >=5 & <=300

					// The number of consecutive health check successes required
					// before considering
					// a target healthy.
					thresholdCount?: uint & >=2 & <=10

					// The amount of time, in seconds, during which no response from a
					// target means
					// a failed health check.
					timeoutSeconds?: uint & >=2 & <=120

					// The number of consecutive health check failures required before
					// considering
					// a target unhealthy.
					unhealthyThresholdCount?: uint & >=2 & <=10
				}

				// HealthCheckProtocol sets the protocol type for ELB health check
				// target
				// default value is ELBProtocolSSL
				healthCheckProtocol?: "TCP" | "SSL" | "HTTP" | "HTTPS" | "TLS" | "UDP"

				// IngressRules sets the ingress rules for the control plane load
				// balancer.
				ingressRules?: [...{
					// List of CIDR blocks to allow access from. Cannot be specified
					// with SourceSecurityGroupID.
					cidrBlocks?: [...string]

					// Description provides extended information about the ingress
					// rule.
					description!: string

					// FromPort is the start of port range.
					fromPort!: int64

					// List of IPv6 CIDR blocks to allow access from. Cannot be
					// specified with SourceSecurityGroupID.
					ipv6CidrBlocks?: [...string]

					// NatGatewaysIPsSource use the NAT gateways IPs as the source for
					// the ingress rule.
					natGatewaysIPsSource?: bool

					// Protocol is the protocol for the ingress rule. Accepted values
					// are "-1" (all), "4" (IP in IP),"tcp", "udp", "icmp", and "58"
					// (ICMPv6), "50" (ESP).
					protocol!: "-1" | "4" | "tcp" | "udp" | "icmp" | "58" | "50"

					// The security group id to allow access from. Cannot be specified
					// with CidrBlocks.
					sourceSecurityGroupIds?: [...string]

					// The security group role to allow access from. Cannot be
					// specified with CidrBlocks.
					// The field will be combined with source security group IDs if
					// specified.
					sourceSecurityGroupRoles?: [..."bastion" | "node" | "controlplane" | "apiserver-lb" | "lb" | "node-eks-additional"]

					// ToPort is the end of port range.
					toPort!: int64
				}]

				// LoadBalancerType sets the type for a load balancer. The default
				// type is classic.
				loadBalancerType?: "classic" | "elb" | "alb" | "nlb" | "disabled"

				// Name sets the name of the classic ELB load balancer. As per
				// AWS, the name must be unique
				// within your set of load balancers for the region, must have a
				// maximum of 32 characters, must
				// contain only alphanumeric characters or hyphens, and cannot
				// begin or end with a hyphen. Once
				// set, the value cannot be changed.
				name?: strings.MaxRunes(32) & {
					=~"^[A-Za-z0-9]([A-Za-z0-9]{0,31}|[-A-Za-z0-9]{0,30}[A-Za-z0-9])$"
				}

				// PreserveClientIP lets the user control if preservation of
				// client ips must be retained or not.
				// If this is enabled 6443 will be opened to 0.0.0.0/0.
				preserveClientIP?: bool

				// Scheme sets the scheme of the load balancer (defaults to
				// internet-facing)
				scheme?: "internet-facing" | "internal"

				// Subnets sets the subnets that should be applied to the control
				// plane load balancer (defaults to discovered subnets for
				// managed VPCs or an empty set for unmanaged VPCs)
				subnets?: [...string]
			}

			// IdentityRef is a reference to an identity to be used when
			// reconciling the managed control plane.
			// If no identity is specified, the default identity for this
			// controller will be used.
			identityRef?: {
				// Kind of the identity.
				kind!: "AWSClusterControllerIdentity" | "AWSClusterRoleIdentity" | "AWSClusterStaticIdentity"

				// Name of the identity.
				name!: strings.MinRunes(1)
			}

			// ImageLookupBaseOS is the name of the base operating system used
			// to look
			// up machine images when a machine does not specify an AMI. When
			// set, this
			// will be used for all cluster machines unless a machine
			// specifies a
			// different ImageLookupBaseOS.
			imageLookupBaseOS?: string

			// ImageLookupFormat is the AMI naming format to look up machine
			// images when
			// a machine does not specify an AMI. When set, this will be used
			// for all
			// cluster machines unless a machine specifies a different
			// ImageLookupOrg.
			// Supports substitutions for {{.BaseOS}} and {{.K8sVersion}} with
			// the base
			// OS and kubernetes version, respectively. The BaseOS will be the
			// value in
			// ImageLookupBaseOS or ubuntu (the default), and the kubernetes
			// version as
			// defined by the packages produced by kubernetes/release without
			// v as a
			// prefix: 1.13.0, 1.12.5-mybuild.1, or 1.17.3. For example, the
			// default
			// image format of capa-ami-{{.BaseOS}}-?{{.K8sVersion}}-* will
			// end up
			// searching for AMIs that match the pattern
			// capa-ami-ubuntu-?1.18.0-* for a
			// Machine that is targeting kubernetes v1.18.0 and the ubuntu
			// base OS. See
			// also: https://golang.org/pkg/text/template/
			imageLookupFormat?: string

			// ImageLookupOrg is the AWS Organization ID to look up machine
			// images when a
			// machine does not specify an AMI. When set, this will be used
			// for all
			// cluster machines unless a machine specifies a different
			// ImageLookupOrg.
			imageLookupOrg?: string

			// NetworkSpec encapsulates all things related to AWS network.
			network?: {
				// AdditionalControlPlaneIngressRules is an optional set of
				// ingress rules to add to the control plane
				additionalControlPlaneIngressRules?: [...{
					// List of CIDR blocks to allow access from. Cannot be specified
					// with SourceSecurityGroupID.
					cidrBlocks?: [...string]

					// Description provides extended information about the ingress
					// rule.
					description!: string

					// FromPort is the start of port range.
					fromPort!: int64

					// List of IPv6 CIDR blocks to allow access from. Cannot be
					// specified with SourceSecurityGroupID.
					ipv6CidrBlocks?: [...string]

					// NatGatewaysIPsSource use the NAT gateways IPs as the source for
					// the ingress rule.
					natGatewaysIPsSource?: bool

					// Protocol is the protocol for the ingress rule. Accepted values
					// are "-1" (all), "4" (IP in IP),"tcp", "udp", "icmp", and "58"
					// (ICMPv6), "50" (ESP).
					protocol!: "-1" | "4" | "tcp" | "udp" | "icmp" | "58" | "50"

					// The security group id to allow access from. Cannot be specified
					// with CidrBlocks.
					sourceSecurityGroupIds?: [...string]

					// The security group role to allow access from. Cannot be
					// specified with CidrBlocks.
					// The field will be combined with source security group IDs if
					// specified.
					sourceSecurityGroupRoles?: [..."bastion" | "node" | "controlplane" | "apiserver-lb" | "lb" | "node-eks-additional"]

					// ToPort is the end of port range.
					toPort!: int64
				}]

				// AdditionalNodeIngressRules is an optional set of ingress rules
				// to add to every node
				additionalNodeIngressRules?: [...{
					// List of CIDR blocks to allow access from. Cannot be specified
					// with SourceSecurityGroupID.
					cidrBlocks?: [...string]

					// Description provides extended information about the ingress
					// rule.
					description!: string

					// FromPort is the start of port range.
					fromPort!: int64

					// List of IPv6 CIDR blocks to allow access from. Cannot be
					// specified with SourceSecurityGroupID.
					ipv6CidrBlocks?: [...string]

					// NatGatewaysIPsSource use the NAT gateways IPs as the source for
					// the ingress rule.
					natGatewaysIPsSource?: bool

					// Protocol is the protocol for the ingress rule. Accepted values
					// are "-1" (all), "4" (IP in IP),"tcp", "udp", "icmp", and "58"
					// (ICMPv6), "50" (ESP).
					protocol!: "-1" | "4" | "tcp" | "udp" | "icmp" | "58" | "50"

					// The security group id to allow access from. Cannot be specified
					// with CidrBlocks.
					sourceSecurityGroupIds?: [...string]

					// The security group role to allow access from. Cannot be
					// specified with CidrBlocks.
					// The field will be combined with source security group IDs if
					// specified.
					sourceSecurityGroupRoles?: [..."bastion" | "node" | "controlplane" | "apiserver-lb" | "lb" | "node-eks-additional"]

					// ToPort is the end of port range.
					toPort!: int64
				}]
				cni?: {
					// CNIIngressRules specify rules to apply to control plane and
					// worker node security groups.
					// The source for the rule will be set to control plane and worker
					// security group IDs.
					cniIngressRules?: [...{
						description!: string
						fromPort!:    int64

						// SecurityGroupProtocol defines the protocol type for a security
						// group rule.
						protocol!: string
						toPort!:   int64
					}]
				}

				// NodePortIngressRuleCidrBlocks is an optional set of CIDR blocks
				// to allow traffic to nodes' NodePort services.
				// If none are specified here, all IPs are allowed to connect.
				nodePortIngressRuleCidrBlocks?: [...string]

				// SecurityGroupOverrides is an optional set of security groups to
				// use for cluster instances
				// This is optional - if not provided new security groups will be
				// created for the cluster
				securityGroupOverrides?: {
					[string]: string
				}

				// Subnets configuration.
				subnets?: [...{
					// AvailabilityZone defines the availability zone to use for this
					// subnet in the cluster's region.
					availabilityZone?: string

					// CidrBlock is the CIDR block to be used when the provider
					// creates a managed VPC.
					cidrBlock?: string

					// ID defines a unique identifier to reference this resource.
					// If you're bringing your subnet, set the AWS subnet-id here, it
					// must start with `subnet-`.
					//
					// When the VPC is managed by CAPA, and you'd like the provider to
					// create a subnet for you,
					// the id can be set to any placeholder value that does not start
					// with `subnet-`;
					// upon creation, the subnet AWS identifier will be populated in
					// the `ResourceID` field and
					// the `id` field is going to be used as the subnet name. If you
					// specify a tag
					// called `Name`, it takes precedence.
					id!: string

					// IPv6CidrBlock is the IPv6 CIDR block to be used when the
					// provider creates a managed VPC.
					// A subnet can have an IPv4 and an IPv6 address.
					// IPv6 is only supported in managed clusters, this field cannot
					// be set on AWSCluster object.
					ipv6CidrBlock?: string

					// IsIPv6 defines the subnet as an IPv6 subnet. A subnet is IPv6
					// when it is associated with a VPC that has IPv6 enabled.
					// IPv6 is only supported in managed clusters, this field cannot
					// be set on AWSCluster object.
					isIpv6?: bool

					// IsPublic defines the subnet as a public subnet. A subnet is
					// public when it is associated with a route table that has a
					// route to an internet gateway.
					isPublic?: bool

					// NatGatewayID is the NAT gateway id associated with the subnet.
					// Ignored unless the subnet is managed by the provider, in which
					// case this is set on the public subnet where the NAT gateway
					// resides. It is then used to determine routes for private
					// subnets in the same AZ as the public subnet.
					natGatewayId?: string

					// ParentZoneName is the zone name where the current subnet's zone
					// is tied when
					// the zone is a Local Zone.
					//
					// The subnets in Local Zone or Wavelength Zone locations consume
					// the ParentZoneName
					// to select the correct private route table to egress traffic to
					// the internet.
					parentZoneName?: string

					// ResourceID is the subnet identifier from AWS, READ ONLY.
					// This field is populated when the provider manages the subnet.
					resourceID?: string

					// RouteTableID is the routing table id associated with the
					// subnet.
					routeTableId?: string

					// Tags is a collection of tags describing the resource.
					tags?: {
						[string]: string
					}

					// ZoneType defines the type of the zone where the subnet is
					// created.
					//
					// The valid values are availability-zone, local-zone, and
					// wavelength-zone.
					//
					// Subnet with zone type availability-zone (regular) is always
					// selected to create cluster
					// resources, like Load Balancers, NAT Gateways, Contol Plane
					// nodes, etc.
					//
					// Subnet with zone type local-zone or wavelength-zone is not
					// eligible to automatically create
					// regular cluster resources.
					//
					// The public subnet in availability-zone or local-zone is
					// associated with regular public
					// route table with default route entry to a Internet Gateway.
					//
					// The public subnet in wavelength-zone is associated with a
					// carrier public
					// route table with default route entry to a Carrier Gateway.
					//
					// The private subnet in the availability-zone is associated with
					// a private route table with
					// the default route entry to a NAT Gateway created in that zone.
					//
					// The private subnet in the local-zone or wavelength-zone is
					// associated with a private route table with
					// the default route entry re-using the NAT Gateway in the Region
					// (preferred from the
					// parent zone, the zone type availability-zone in the region, or
					// first table available).
					zoneType?: "availability-zone" | "local-zone" | "wavelength-zone"
				}]

				// VPC configuration.
				vpc?: {
					// AvailabilityZoneSelection specifies how AZs should be selected
					// if there are more AZs
					// in a region than specified by AvailabilityZoneUsageLimit. There
					// are 2 selection schemes:
					// Ordered - selects based on alphabetical order
					// Random - selects AZs randomly in a region
					// Defaults to Ordered
					availabilityZoneSelection?: "Ordered" | "Random"

					// AvailabilityZoneUsageLimit specifies the maximum number of
					// availability zones (AZ) that
					// should be used in a region when automatically creating subnets.
					// If a region has more
					// than this number of AZs then this number of AZs will be picked
					// randomly when creating
					// default subnets. Defaults to 3
					availabilityZoneUsageLimit?: int & >=1

					// CarrierGatewayID is the id of the internet gateway associated
					// with the VPC,
					// for carrier network (Wavelength Zones).
					carrierGatewayId?: string

					// CidrBlock is the CIDR block to be used when the provider
					// creates a managed VPC.
					// Defaults to 10.0.0.0/16.
					// Mutually exclusive with IPAMPool.
					cidrBlock?: string

					// ElasticIPPool contains specific configuration to allocate
					// Public IPv4 address (Elastic IP) from user-defined pool
					// brought to AWS for core infrastructure resources, like NAT
					// Gateways and Public Network Load Balancers for
					// the API Server.
					elasticIpPool?: {
						// PublicIpv4Pool sets a custom Public IPv4 Pool used to create
						// Elastic IP address for resources
						// created in public IPv4 subnets. Every IPv4 address, Elastic IP,
						// will be allocated from the custom
						// Public IPv4 pool that you brought to AWS, instead of
						// Amazon-provided pool. The public IPv4 pool
						// resource ID starts with 'ipv4pool-ec2'.
						publicIpv4Pool?: strings.MaxRunes(30)

						// PublicIpv4PoolFallBackOrder defines the fallback action when
						// the Public IPv4 Pool has been exhausted,
						// no more IPv4 address available in the pool.
						//
						// When set to 'amazon-pool', the controller check if the pool has
						// available IPv4 address, when pool has reached the
						// IPv4 limit, the address will be claimed from Amazon-pool
						// (default).
						//
						// When set to 'none', the controller will fail the Elastic IP
						// allocation when the publicIpv4Pool is exhausted.
						publicIpv4PoolFallbackOrder?: "amazon-pool" | "none"
					}

					// EmptyRoutesDefaultVPCSecurityGroup specifies whether the
					// default VPC security group ingress
					// and egress rules should be removed.
					//
					// By default, when creating a VPC, AWS creates a security group
					// called `default` with ingress and egress
					// rules that allow traffic from anywhere. The group could be used
					// as a potential surface attack and
					// it's generally suggested that the group rules are removed or
					// modified appropriately.
					//
					// NOTE: This only applies when the VPC is managed by the Cluster
					// API AWS controller.
					emptyRoutesDefaultVPCSecurityGroup?: bool

					// ID is the vpc-id of the VPC this provider should use to create
					// resources.
					id?: string

					// InternetGatewayID is the id of the internet gateway associated
					// with the VPC.
					internetGatewayId?: string

					// IPAMPool defines the IPAMv4 pool to be used for VPC.
					// Mutually exclusive with CidrBlock.
					ipamPool?: {
						// ID is the ID of the IPAM pool this provider should use to
						// create VPC.
						id?: string

						// Name is the name of the IPAM pool this provider should use to
						// create VPC.
						name?: string

						// The netmask length of the IPv4 CIDR you want to allocate to VPC
						// from
						// an Amazon VPC IP Address Manager (IPAM) pool.
						// Defaults to /16 for IPv4 if not specified.
						netmaskLength?: int64
					}

					// IPv6 contains ipv6 specific settings for the network. Supported
					// only in managed clusters.
					// This field cannot be set on AWSCluster object.
					ipv6?: {
						// CidrBlock is the CIDR block provided by Amazon when VPC has
						// enabled IPv6.
						// Mutually exclusive with IPAMPool.
						cidrBlock?: string

						// EgressOnlyInternetGatewayID is the id of the egress only
						// internet gateway associated with an IPv6 enabled VPC.
						egressOnlyInternetGatewayId?: string

						// IPAMPool defines the IPAMv6 pool to be used for VPC.
						// Mutually exclusive with CidrBlock.
						ipamPool?: {
							// ID is the ID of the IPAM pool this provider should use to
							// create VPC.
							id?: string

							// Name is the name of the IPAM pool this provider should use to
							// create VPC.
							name?: string

							// The netmask length of the IPv4 CIDR you want to allocate to VPC
							// from
							// an Amazon VPC IP Address Manager (IPAM) pool.
							// Defaults to /16 for IPv4 if not specified.
							netmaskLength?: int64
						}

						// PoolID is the IP pool which must be defined in case of BYO IP
						// is defined.
						// Must be specified if CidrBlock is set.
						// Mutually exclusive with IPAMPool.
						poolId?: string
					}

					// PrivateDNSHostnameTypeOnLaunch is the type of hostname to
					// assign to instances in the subnet at launch.
					// For IPv4-only and dual-stack (IPv4 and IPv6) subnets, an
					// instance DNS name can be based on the instance IPv4 address
					// (ip-name)
					// or the instance ID (resource-name). For IPv6 only subnets, an
					// instance DNS name must be based on the instance ID
					// (resource-name).
					privateDnsHostnameTypeOnLaunch?: "ip-name" | "resource-name"

					// SecondaryCidrBlocks are additional CIDR blocks to be associated
					// when the provider creates a managed VPC.
					// Defaults to none. Mutually exclusive with IPAMPool. This makes
					// sense to use if, for example, you want to use
					// a separate IP range for pods (e.g. Cilium ENI mode).
					secondaryCidrBlocks?: [...{
						// IPv4CidrBlock is the IPv4 CIDR block to associate with the
						// managed VPC.
						ipv4CidrBlock!: strings.MinRunes(1)
					}]

					// SubnetSchema specifies how CidrBlock should be divided on
					// subnets in the VPC depending on the number of AZs.
					// PreferPrivate - one private subnet for each AZ plus one other
					// subnet that will be further sub-divided for the public
					// subnets.
					// PreferPublic - have the reverse logic of PreferPrivate, one
					// public subnet for each AZ plus one other subnet
					// that will be further sub-divided for the private subnets.
					// Defaults to PreferPrivate
					subnetSchema?: "PreferPrivate" | "PreferPublic"

					// Tags is a collection of tags describing the resource.
					tags?: {
						[string]: string
					}
				}
			}

			// Partition is the AWS security partition being used. Defaults to
			// "aws"
			partition?: string

			// The AWS Region the cluster lives in.
			region?: string

			// S3Bucket contains options to configure a supporting S3 bucket
			// for this
			// cluster - currently used for nodes requiring Ignition
			// (https://coreos.github.io/ignition/) for bootstrapping
			// (requires
			// BootstrapFormatIgnition feature flag to be enabled).
			s3Bucket?: {
				// BestEffortDeleteObjects defines whether access/permission
				// errors during object deletion should be ignored.
				bestEffortDeleteObjects?: bool

				// ControlPlaneIAMInstanceProfile is a name of the
				// IAMInstanceProfile, which will be allowed
				// to read control-plane node bootstrap data from S3 Bucket.
				controlPlaneIAMInstanceProfile?: string

				// Name defines name of S3 Bucket to be created.
				name!: strings.MaxRunes(63) & strings.MinRunes(3) & {
					=~"^[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]$"
				}

				// NodesIAMInstanceProfiles is a list of IAM instance profiles,
				// which will be allowed to read
				// worker nodes bootstrap data from S3 Bucket.
				nodesIAMInstanceProfiles?: [...string]

				// PresignedURLDuration defines the duration for which presigned
				// URLs are valid.
				//
				// This is used to generate presigned URLs for S3 Bucket objects,
				// which are used by
				// control-plane and worker nodes to fetch bootstrap data.
				//
				// When enabled, the IAM instance profiles specified are not used.
				presignedURLDuration?: string
			}

			// SecondaryControlPlaneLoadBalancer is an additional load
			// balancer that can be used for the control plane.
			//
			// An example use case is to have a separate internal load
			// balancer for internal traffic,
			// and a separate external load balancer for external traffic.
			secondaryControlPlaneLoadBalancer?: {
				// AdditionalListeners sets the additional listeners for the
				// control plane load balancer.
				// This is only applicable to Network Load Balancer (NLB) types
				// for the time being.
				additionalListeners?: [...{
					// HealthCheck sets the optional custom health check configuration
					// to the API target group.
					healthCheck?: {
						// The approximate amount of time, in seconds, between health
						// checks of an individual
						// target.
						intervalSeconds?: uint & >=5 & <=300

						// The destination for health checks on the targets when using the
						// protocol HTTP or HTTPS,
						// otherwise the path will be ignored.
						path?: string

						// The port the load balancer uses when performing health checks
						// for additional target groups. When
						// not specified this value will be set for the same of listener
						// port.
						port?: string

						// The protocol to use to health check connect with the target.
						// When not specified the Protocol
						// will be the same of the listener.
						protocol?: "TCP" | "HTTP" | "HTTPS"

						// The number of consecutive health check successes required
						// before considering
						// a target healthy.
						thresholdCount?: uint & >=2 & <=10

						// The amount of time, in seconds, during which no response from a
						// target means
						// a failed health check.
						timeoutSeconds?: uint & >=2 & <=120

						// The number of consecutive health check failures required before
						// considering
						// a target unhealthy.
						unhealthyThresholdCount?: uint & >=2 & <=10
					}

					// Port sets the port for the additional listener.
					port!: uint16 & >=1

					// Protocol sets the protocol for the additional listener.
					// Currently only TCP is supported.
					protocol?: "TCP"
				}]

				// AdditionalSecurityGroups sets the security groups used by the
				// load balancer. Expected to be security group IDs
				// This is optional - if not provided new security groups will be
				// created for the load balancer
				additionalSecurityGroups?: [...string]

				// CrossZoneLoadBalancing enables the classic ELB cross
				// availability zone balancing.
				//
				// With cross-zone load balancing, each load balancer node for
				// your Classic Load Balancer
				// distributes requests evenly across the registered instances in
				// all enabled Availability Zones.
				// If cross-zone load balancing is disabled, each load balancer
				// node distributes requests evenly across
				// the registered instances in its Availability Zone only.
				//
				// Defaults to false.
				crossZoneLoadBalancing?: bool

				// DisableHostsRewrite disabled the hair pinning issue solution
				// that adds the NLB's address as 127.0.0.1 to the hosts
				// file of each instance. This is by default, false.
				disableHostsRewrite?: bool

				// HealthCheck sets custom health check configuration to the API
				// target group.
				healthCheck?: {
					// The approximate amount of time, in seconds, between health
					// checks of an individual
					// target.
					intervalSeconds?: uint & >=5 & <=300

					// The number of consecutive health check successes required
					// before considering
					// a target healthy.
					thresholdCount?: uint & >=2 & <=10

					// The amount of time, in seconds, during which no response from a
					// target means
					// a failed health check.
					timeoutSeconds?: uint & >=2 & <=120

					// The number of consecutive health check failures required before
					// considering
					// a target unhealthy.
					unhealthyThresholdCount?: uint & >=2 & <=10
				}

				// HealthCheckProtocol sets the protocol type for ELB health check
				// target
				// default value is ELBProtocolSSL
				healthCheckProtocol?: "TCP" | "SSL" | "HTTP" | "HTTPS" | "TLS" | "UDP"

				// IngressRules sets the ingress rules for the control plane load
				// balancer.
				ingressRules?: [...{
					// List of CIDR blocks to allow access from. Cannot be specified
					// with SourceSecurityGroupID.
					cidrBlocks?: [...string]

					// Description provides extended information about the ingress
					// rule.
					description!: string

					// FromPort is the start of port range.
					fromPort!: int64

					// List of IPv6 CIDR blocks to allow access from. Cannot be
					// specified with SourceSecurityGroupID.
					ipv6CidrBlocks?: [...string]

					// NatGatewaysIPsSource use the NAT gateways IPs as the source for
					// the ingress rule.
					natGatewaysIPsSource?: bool

					// Protocol is the protocol for the ingress rule. Accepted values
					// are "-1" (all), "4" (IP in IP),"tcp", "udp", "icmp", and "58"
					// (ICMPv6), "50" (ESP).
					protocol!: "-1" | "4" | "tcp" | "udp" | "icmp" | "58" | "50"

					// The security group id to allow access from. Cannot be specified
					// with CidrBlocks.
					sourceSecurityGroupIds?: [...string]

					// The security group role to allow access from. Cannot be
					// specified with CidrBlocks.
					// The field will be combined with source security group IDs if
					// specified.
					sourceSecurityGroupRoles?: [..."bastion" | "node" | "controlplane" | "apiserver-lb" | "lb" | "node-eks-additional"]

					// ToPort is the end of port range.
					toPort!: int64
				}]

				// LoadBalancerType sets the type for a load balancer. The default
				// type is classic.
				loadBalancerType?: "classic" | "elb" | "alb" | "nlb" | "disabled"

				// Name sets the name of the classic ELB load balancer. As per
				// AWS, the name must be unique
				// within your set of load balancers for the region, must have a
				// maximum of 32 characters, must
				// contain only alphanumeric characters or hyphens, and cannot
				// begin or end with a hyphen. Once
				// set, the value cannot be changed.
				name?: strings.MaxRunes(32) & {
					=~"^[A-Za-z0-9]([A-Za-z0-9]{0,31}|[-A-Za-z0-9]{0,30}[A-Za-z0-9])$"
				}

				// PreserveClientIP lets the user control if preservation of
				// client ips must be retained or not.
				// If this is enabled 6443 will be opened to 0.0.0.0/0.
				preserveClientIP?: bool

				// Scheme sets the scheme of the load balancer (defaults to
				// internet-facing)
				scheme?: "internet-facing" | "internal"

				// Subnets sets the subnets that should be applied to the control
				// plane load balancer (defaults to discovered subnets for
				// managed VPCs or an empty set for unmanaged VPCs)
				subnets?: [...string]
			}

			// SSHKeyName is the name of the ssh key to attach to the bastion
			// host. Valid values are empty string (do not use SSH keys), a
			// valid SSH key name, or omitted (use the default SSH key name)
			sshKeyName?: string
		}
	}
}
