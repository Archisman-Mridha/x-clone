// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f /tmp/kue/cluster-api-operator/config/crd/bases/operator.cluster.x-k8s.io_infrastructureproviders.yaml

package v1alpha2

import "strings"

// InfrastructureProvider is the Schema for the
// infrastructureproviders API.
#InfrastructureProvider: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "operator.cluster.x-k8s.io/v1alpha2"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "InfrastructureProvider"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// InfrastructureProviderSpec defines the desired state of
	// InfrastructureProvider.
	spec!: #InfrastructureProviderSpec
}

// InfrastructureProviderSpec defines the desired state of
// InfrastructureProvider.
#InfrastructureProviderSpec: {
	// AdditionalDeployments is a map of additional deployments that
	// the provider
	// should manage. The key is the name of the deployment and the
	// value is the
	// DeploymentSpec.
	additionalDeployments?: {
		[string]: {
			// Deployment defines the properties that can be enabled on the
			// deployment for the additional provider deployment.
			deployment?: {
				// If specified, the pod's scheduling constraints
				affinity?: {
					// Describes node affinity scheduling rules for the pod.
					nodeAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy
						// the affinity expressions specified by this field, but it may
						// choose
						// a node that violates one or more of the expressions. The node
						// that is
						// most preferred is the one with the greatest sum of weights,
						// i.e.
						// for each node that meets all of the scheduling requirements
						// (resource
						// request, requiredDuringScheduling affinity expressions, etc.),
						// compute a sum by iterating through the elements of this field
						// and adding
						// "weight" to the sum if the node matches the corresponding
						// matchExpressions; the
						// node(s) with the highest sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// A node selector term, associated with the corresponding weight.
							preference!: {
								// A list of node selector requirements by node's labels.
								matchExpressions?: [...{
									// The label key that the selector applies to.
									key!: string

									// Represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
									// Lt.
									operator!: string

									// An array of string values. If the operator is In or NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. If the operator is Gt or Lt,
									// the values
									// array must have a single element, which will be interpreted as
									// an integer.
									// This array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// A list of node selector requirements by node's fields.
								matchFields?: [...{
									// The label key that the selector applies to.
									key!: string

									// Represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
									// Lt.
									operator!: string

									// An array of string values. If the operator is In or NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. If the operator is Gt or Lt,
									// the values
									// array must have a single element, which will be interpreted as
									// an integer.
									// This array is replaced during a strategic merge patch.
									values?: [...string]
								}]
							}

							// Weight associated with matching the corresponding
							// nodeSelectorTerm, in the range 1-100.
							weight!: int32
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: {
							// Required. A list of node selector terms. The terms are ORed.
							nodeSelectorTerms!: [...{
								// A list of node selector requirements by node's labels.
								matchExpressions?: [...{
									// The label key that the selector applies to.
									key!: string

									// Represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
									// Lt.
									operator!: string

									// An array of string values. If the operator is In or NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. If the operator is Gt or Lt,
									// the values
									// array must have a single element, which will be interpreted as
									// an integer.
									// This array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// A list of node selector requirements by node's fields.
								matchFields?: [...{
									// The label key that the selector applies to.
									key!: string

									// Represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
									// Lt.
									operator!: string

									// An array of string values. If the operator is In or NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. If the operator is Gt or Lt,
									// the values
									// array must have a single element, which will be interpreted as
									// an integer.
									// This array is replaced during a strategic merge patch.
									values?: [...string]
								}]
							}]
						}
					}

					// Describes pod affinity scheduling rules (e.g. co-locate this
					// pod in the same node, zone, etc. as some other pod(s)).
					podAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy
						// the affinity expressions specified by this field, but it may
						// choose
						// a node that violates one or more of the expressions. The node
						// that is
						// most preferred is the one with the greatest sum of weights,
						// i.e.
						// for each node that meets all of the scheduling requirements
						// (resource
						// request, requiredDuringScheduling affinity expressions, etc.),
						// compute a sum by iterating through the elements of this field
						// and adding
						// "weight" to the sum if the node has pods which matches the
						// corresponding podAffinityTerm; the
						// node(s) with the highest sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// Required. A pod affinity term, associated with the
							// corresponding weight.
							podAffinityTerm!: {
								// A label query over a set of resources, in this case pods.
								// If it's null, this PodAffinityTerm matches with no Pods.
								labelSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key!: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator!: string

										// values is an array of string values. If the operator is In or
										// NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. This array is replaced during a
										// strategic
										// merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels
									// map is equivalent to an element of matchExpressions, whose key
									// field is "key", the
									// operator is "In", and the values array contains only "value".
									// The requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// MatchLabelKeys is a set of pod label keys to select which pods
								// will
								// be taken into consideration. The keys are used to lookup values
								// from the
								// incoming pod labels, those key-value labels are merged with
								// `labelSelector` as `key in (value)`
								// to select the group of existing pods which pods will be taken
								// into consideration
								// for the incoming pod's pod (anti) affinity. Keys that don't
								// exist in the incoming
								// pod labels will be ignored. The default value is empty.
								// The same key is forbidden to exist in both matchLabelKeys and
								// labelSelector.
								// Also, matchLabelKeys cannot be set when labelSelector isn't
								// set.
								// This is a beta field and requires enabling
								// MatchLabelKeysInPodAffinity feature gate (enabled by default).
								matchLabelKeys?: [...string]

								// MismatchLabelKeys is a set of pod label keys to select which
								// pods will
								// be taken into consideration. The keys are used to lookup values
								// from the
								// incoming pod labels, those key-value labels are merged with
								// `labelSelector` as `key notin (value)`
								// to select the group of existing pods which pods will be taken
								// into consideration
								// for the incoming pod's pod (anti) affinity. Keys that don't
								// exist in the incoming
								// pod labels will be ignored. The default value is empty.
								// The same key is forbidden to exist in both mismatchLabelKeys
								// and labelSelector.
								// Also, mismatchLabelKeys cannot be set when labelSelector isn't
								// set.
								// This is a beta field and requires enabling
								// MatchLabelKeysInPodAffinity feature gate (enabled by default).
								mismatchLabelKeys?: [...string]

								// A label query over the set of namespaces that the term applies
								// to.
								// The term is applied to the union of the namespaces selected by
								// this field
								// and the ones listed in the namespaces field.
								// null selector and null or empty namespaces list means "this
								// pod's namespace".
								// An empty selector ({}) matches all namespaces.
								namespaceSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key!: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator!: string

										// values is an array of string values. If the operator is In or
										// NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. This array is replaced during a
										// strategic
										// merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels
									// map is equivalent to an element of matchExpressions, whose key
									// field is "key", the
									// operator is "In", and the values array contains only "value".
									// The requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// namespaces specifies a static list of namespace names that the
								// term applies to.
								// The term is applied to the union of the namespaces listed in
								// this field
								// and the ones selected by namespaceSelector.
								// null or empty namespaces list and null namespaceSelector means
								// "this pod's namespace".
								namespaces?: [...string]

								// This pod should be co-located (affinity) or not co-located
								// (anti-affinity) with the pods matching
								// the labelSelector in the specified namespaces, where co-located
								// is defined as running on a node
								// whose value of the label with key topologyKey matches that of
								// any node on which any of the
								// selected pods is running.
								// Empty topologyKey is not allowed.
								topologyKey!: string
							}

							// weight associated with matching the corresponding
							// podAffinityTerm,
							// in the range 1-100.
							weight!: int32
						}]

						// If the affinity requirements specified by this field are not
						// met at
						// scheduling time, the pod will not be scheduled onto the node.
						// If the affinity requirements specified by this field cease to
						// be met
						// at some point during pod execution (e.g. due to a pod label
						// update), the
						// system may or may not try to eventually evict the pod from its
						// node.
						// When there are multiple elements, the lists of nodes
						// corresponding to each
						// podAffinityTerm are intersected, i.e. all terms must be
						// satisfied.
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							// A label query over a set of resources, in this case pods.
							// If it's null, this PodAffinityTerm matches with no Pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key!: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator!: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// MatchLabelKeys is a set of pod label keys to select which pods
							// will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// `labelSelector` as `key in (value)`
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both matchLabelKeys and
							// labelSelector.
							// Also, matchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is a beta field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate (enabled by default).
							matchLabelKeys?: [...string]

							// MismatchLabelKeys is a set of pod label keys to select which
							// pods will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// `labelSelector` as `key notin (value)`
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both mismatchLabelKeys
							// and labelSelector.
							// Also, mismatchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is a beta field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate (enabled by default).
							mismatchLabelKeys?: [...string]

							// A label query over the set of namespaces that the term applies
							// to.
							// The term is applied to the union of the namespaces selected by
							// this field
							// and the ones listed in the namespaces field.
							// null selector and null or empty namespaces list means "this
							// pod's namespace".
							// An empty selector ({}) matches all namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key!: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator!: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to.
							// The term is applied to the union of the namespaces listed in
							// this field
							// and the ones selected by namespaceSelector.
							// null or empty namespaces list and null namespaceSelector means
							// "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching
							// the labelSelector in the specified namespaces, where co-located
							// is defined as running on a node
							// whose value of the label with key topologyKey matches that of
							// any node on which any of the
							// selected pods is running.
							// Empty topologyKey is not allowed.
							topologyKey!: string
						}]
					}

					// Describes pod anti-affinity scheduling rules (e.g. avoid
					// putting this pod in the same node, zone, etc. as some other
					// pod(s)).
					podAntiAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy
						// the anti-affinity expressions specified by this field, but it
						// may choose
						// a node that violates one or more of the expressions. The node
						// that is
						// most preferred is the one with the greatest sum of weights,
						// i.e.
						// for each node that meets all of the scheduling requirements
						// (resource
						// request, requiredDuringScheduling anti-affinity expressions,
						// etc.),
						// compute a sum by iterating through the elements of this field
						// and adding
						// "weight" to the sum if the node has pods which matches the
						// corresponding podAffinityTerm; the
						// node(s) with the highest sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// Required. A pod affinity term, associated with the
							// corresponding weight.
							podAffinityTerm!: {
								// A label query over a set of resources, in this case pods.
								// If it's null, this PodAffinityTerm matches with no Pods.
								labelSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key!: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator!: string

										// values is an array of string values. If the operator is In or
										// NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. This array is replaced during a
										// strategic
										// merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels
									// map is equivalent to an element of matchExpressions, whose key
									// field is "key", the
									// operator is "In", and the values array contains only "value".
									// The requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// MatchLabelKeys is a set of pod label keys to select which pods
								// will
								// be taken into consideration. The keys are used to lookup values
								// from the
								// incoming pod labels, those key-value labels are merged with
								// `labelSelector` as `key in (value)`
								// to select the group of existing pods which pods will be taken
								// into consideration
								// for the incoming pod's pod (anti) affinity. Keys that don't
								// exist in the incoming
								// pod labels will be ignored. The default value is empty.
								// The same key is forbidden to exist in both matchLabelKeys and
								// labelSelector.
								// Also, matchLabelKeys cannot be set when labelSelector isn't
								// set.
								// This is a beta field and requires enabling
								// MatchLabelKeysInPodAffinity feature gate (enabled by default).
								matchLabelKeys?: [...string]

								// MismatchLabelKeys is a set of pod label keys to select which
								// pods will
								// be taken into consideration. The keys are used to lookup values
								// from the
								// incoming pod labels, those key-value labels are merged with
								// `labelSelector` as `key notin (value)`
								// to select the group of existing pods which pods will be taken
								// into consideration
								// for the incoming pod's pod (anti) affinity. Keys that don't
								// exist in the incoming
								// pod labels will be ignored. The default value is empty.
								// The same key is forbidden to exist in both mismatchLabelKeys
								// and labelSelector.
								// Also, mismatchLabelKeys cannot be set when labelSelector isn't
								// set.
								// This is a beta field and requires enabling
								// MatchLabelKeysInPodAffinity feature gate (enabled by default).
								mismatchLabelKeys?: [...string]

								// A label query over the set of namespaces that the term applies
								// to.
								// The term is applied to the union of the namespaces selected by
								// this field
								// and the ones listed in the namespaces field.
								// null selector and null or empty namespaces list means "this
								// pod's namespace".
								// An empty selector ({}) matches all namespaces.
								namespaceSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key!: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator!: string

										// values is an array of string values. If the operator is In or
										// NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. This array is replaced during a
										// strategic
										// merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels
									// map is equivalent to an element of matchExpressions, whose key
									// field is "key", the
									// operator is "In", and the values array contains only "value".
									// The requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// namespaces specifies a static list of namespace names that the
								// term applies to.
								// The term is applied to the union of the namespaces listed in
								// this field
								// and the ones selected by namespaceSelector.
								// null or empty namespaces list and null namespaceSelector means
								// "this pod's namespace".
								namespaces?: [...string]

								// This pod should be co-located (affinity) or not co-located
								// (anti-affinity) with the pods matching
								// the labelSelector in the specified namespaces, where co-located
								// is defined as running on a node
								// whose value of the label with key topologyKey matches that of
								// any node on which any of the
								// selected pods is running.
								// Empty topologyKey is not allowed.
								topologyKey!: string
							}

							// weight associated with matching the corresponding
							// podAffinityTerm,
							// in the range 1-100.
							weight!: int32
						}]

						// If the anti-affinity requirements specified by this field are
						// not met at
						// scheduling time, the pod will not be scheduled onto the node.
						// If the anti-affinity requirements specified by this field cease
						// to be met
						// at some point during pod execution (e.g. due to a pod label
						// update), the
						// system may or may not try to eventually evict the pod from its
						// node.
						// When there are multiple elements, the lists of nodes
						// corresponding to each
						// podAffinityTerm are intersected, i.e. all terms must be
						// satisfied.
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							// A label query over a set of resources, in this case pods.
							// If it's null, this PodAffinityTerm matches with no Pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key!: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator!: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// MatchLabelKeys is a set of pod label keys to select which pods
							// will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// `labelSelector` as `key in (value)`
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both matchLabelKeys and
							// labelSelector.
							// Also, matchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is a beta field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate (enabled by default).
							matchLabelKeys?: [...string]

							// MismatchLabelKeys is a set of pod label keys to select which
							// pods will
							// be taken into consideration. The keys are used to lookup values
							// from the
							// incoming pod labels, those key-value labels are merged with
							// `labelSelector` as `key notin (value)`
							// to select the group of existing pods which pods will be taken
							// into consideration
							// for the incoming pod's pod (anti) affinity. Keys that don't
							// exist in the incoming
							// pod labels will be ignored. The default value is empty.
							// The same key is forbidden to exist in both mismatchLabelKeys
							// and labelSelector.
							// Also, mismatchLabelKeys cannot be set when labelSelector isn't
							// set.
							// This is a beta field and requires enabling
							// MatchLabelKeysInPodAffinity feature gate (enabled by default).
							mismatchLabelKeys?: [...string]

							// A label query over the set of namespaces that the term applies
							// to.
							// The term is applied to the union of the namespaces selected by
							// this field
							// and the ones listed in the namespaces field.
							// null selector and null or empty namespaces list means "this
							// pod's namespace".
							// An empty selector ({}) matches all namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key!: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator!: string

									// values is an array of string values. If the operator is In or
									// NotIn,
									// the values array must be non-empty. If the operator is Exists
									// or DoesNotExist,
									// the values array must be empty. This array is replaced during a
									// strategic
									// merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels
								// map is equivalent to an element of matchExpressions, whose key
								// field is "key", the
								// operator is "In", and the values array contains only "value".
								// The requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to.
							// The term is applied to the union of the namespaces listed in
							// this field
							// and the ones selected by namespaceSelector.
							// null or empty namespaces list and null namespaceSelector means
							// "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching
							// the labelSelector in the specified namespaces, where co-located
							// is defined as running on a node
							// whose value of the label with key topologyKey matches that of
							// any node on which any of the
							// selected pods is running.
							// Empty topologyKey is not allowed.
							topologyKey!: string
						}]
					}
				}

				// List of containers specified in the Deployment
				containers?: [...{
					// Args represents extra provider specific flags that are not
					// encoded as fields in this API.
					// Explicit controller manager properties defined in the
					// `Provider.ManagerSpec`
					// will have higher precedence than those defined in
					// `ContainerSpec.Args`.
					// For example, `ManagerSpec.SyncPeriod` will be used instead of
					// the
					// container arg `--sync-period` if both are defined.
					// The same holds for `ManagerSpec.FeatureGates` and
					// `--feature-gates`.
					args?: {
						[string]: string
					}

					// Command allows override container's entrypoint array.
					command?: [...string]

					// List of environment variables to set in the container.
					env?: [...{
						// Name of the environment variable. Must be a C_IDENTIFIER.
						name!: string

						// Variable references $(VAR_NAME) are expanded
						// using the previously defined environment variables in the
						// container and
						// any service environment variables. If a variable cannot be
						// resolved,
						// the reference in the input string will be unchanged. Double $$
						// are reduced
						// to a single $, which allows for escaping the $(VAR_NAME)
						// syntax: i.e.
						// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
						// Escaped references will never be expanded, regardless of
						// whether the variable
						// exists or not.
						// Defaults to "".
						value?: string

						// Source for the environment variable's value. Cannot be used if
						// value is not empty.
						valueFrom?: {
							// Selects a key of a ConfigMap.
							configMapKeyRef?: {
								// The key to select.
								key!: string

								// Name of the referent.
								// This field is effectively required, but due to backwards
								// compatibility is
								// allowed to be empty. Instances of this type with an empty value
								// here are
								// almost certainly wrong.
								// More info:
								// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
								name?: string

								// Specify whether the ConfigMap or its key must be defined
								optional?: bool
							}

							// Selects a field of the pod: supports metadata.name,
							// metadata.namespace, `metadata.labels['<KEY>']`,
							// `metadata.annotations['<KEY>']`,
							// spec.nodeName, spec.serviceAccountName, status.hostIP,
							// status.podIP, status.podIPs.
							fieldRef?: {
								// Version of the schema the FieldPath is written in terms of,
								// defaults to "v1".
								apiVersion?: string

								// Path of the field to select in the specified API version.
								fieldPath!: string
							}

							// Selects a resource of the container: only resources limits and
							// requests
							// (limits.cpu, limits.memory, limits.ephemeral-storage,
							// requests.cpu, requests.memory and requests.ephemeral-storage)
							// are currently supported.
							resourceFieldRef?: {
								// Container name: required for volumes, optional for env vars
								containerName?: string

								// Specifies the output format of the exposed resources, defaults
								// to "1"
								divisor?: matchN(>=1, [int, string]) & (number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$")

								// Required: resource to select
								resource!: string
							}

							// Selects a key of a secret in the pod's namespace
							secretKeyRef?: {
								// The key of the secret to select from. Must be a valid secret
								// key.
								key!: string

								// Name of the referent.
								// This field is effectively required, but due to backwards
								// compatibility is
								// allowed to be empty. Instances of this type with an empty value
								// here are
								// almost certainly wrong.
								// More info:
								// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
								name?: string

								// Specify whether the Secret or its key must be defined
								optional?: bool
							}
						}
					}]

					// Container Image URL
					imageUrl?: string

					// Name of the container. Cannot be updated.
					name!: string

					// Compute resources required by this container.
					resources?: {
						// Claims lists the names of resources, defined in
						// spec.resourceClaims,
						// that are used by this container.
						//
						// This is an alpha field and requires enabling the
						// DynamicResourceAllocation feature gate.
						//
						// This field is immutable. It can only be set for containers.
						claims?: [...{
							// Name must match the name of one entry in
							// pod.spec.resourceClaims of
							// the Pod where this field is used. It makes that resource
							// available
							// inside a container.
							name!: string

							// Request is the name chosen for a request in the referenced
							// claim.
							// If empty, everything from the claim is made available,
							// otherwise
							// only the result of this request.
							request?: string
						}]

						// Limits describes the maximum amount of compute resources
						// allowed.
						// More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						limits?: {
							[string]: matchN(>=1, [int, string]) & (number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$")
						}

						// Requests describes the minimum amount of compute resources
						// required.
						// If Requests is omitted for a container, it defaults to Limits
						// if that is explicitly specified,
						// otherwise to an implementation-defined value. Requests cannot
						// exceed Limits.
						// More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						requests?: {
							[string]: matchN(>=1, [int, string]) & (number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$")
						}
					}
				}]

				// List of image pull secrets specified in the Deployment
				imagePullSecrets?: [...{
					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string
				}]

				// NodeSelector is a selector which must be true for the pod to
				// fit on a node.
				// Selector which must match a node's labels for the pod to be
				// scheduled on that node.
				// More info:
				// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
				nodeSelector?: {
					[string]: string
				}

				// Number of desired pods. This is a pointer to distinguish
				// between explicit zero and not specified. Defaults to 1.
				replicas?: int & >=0

				// If specified, the pod's service account
				serviceAccountName?: string

				// If specified, the pod's tolerations.
				tolerations?: [...{
					// Effect indicates the taint effect to match. Empty means match
					// all taint effects.
					// When specified, allowed values are NoSchedule, PreferNoSchedule
					// and NoExecute.
					effect?: string

					// Key is the taint key that the toleration applies to. Empty
					// means match all taint keys.
					// If the key is empty, operator must be Exists; this combination
					// means to match all values and all keys.
					key?: string

					// Operator represents a key's relationship to the value.
					// Valid operators are Exists and Equal. Defaults to Equal.
					// Exists is equivalent to wildcard for value, so that a pod can
					// tolerate all taints of a particular category.
					operator?: string

					// TolerationSeconds represents the period of time the toleration
					// (which must be
					// of effect NoExecute, otherwise this field is ignored) tolerates
					// the taint. By default,
					// it is not set, which means tolerate the taint forever (do not
					// evict). Zero and
					// negative values will be treated as 0 (evict immediately) by the
					// system.
					tolerationSeconds?: int64

					// Value is the taint value the toleration matches to.
					// If the operator is Exists, the value should be empty, otherwise
					// just a regular string.
					value?: string
				}]
			}

			// Manager defines the properties that can be enabled on the
			// controller manager for the additional provider deployment.
			manager?: {
				// AdditionalArgs is a map of additional options that will be
				// passed
				// in as container args to the provider's controller manager.
				additionalArgs?: {
					[string]: string
				}

				// CacheNamespace if specified restricts the manager's cache to
				// watch objects in
				// the desired namespace Defaults to all namespaces
				//
				// Note: If a namespace is specified, controllers can still Watch
				// for a
				// cluster-scoped resource (e.g Node). For namespaced resources
				// the cache
				// will only hold objects from the desired namespace.
				cacheNamespace?: string

				// Controller contains global configuration options for
				// controllers
				// registered within this manager.
				controller?: {
					// CacheSyncTimeout refers to the time limit set to wait for
					// syncing caches.
					// Defaults to 2 minutes if not set.
					cacheSyncTimeout?: int64

					// GroupKindConcurrency is a map from a Kind to the number of
					// concurrent reconciliation
					// allowed for that controller.
					//
					// When a controller is registered within this manager using the
					// builder utilities,
					// users have to specify the type the controller reconciles in the
					// For(...) call.
					// If the object's kind passed matches one of the keys in this
					// map, the concurrency
					// for that controller is set to the number specified.
					//
					// The key is expected to be consistent in form with
					// GroupKind.String(),
					// e.g. ReplicaSet in apps group (regardless of version) would be
					// `ReplicaSet.apps`.
					groupKindConcurrency?: {
						[string]: int
					}

					// RecoverPanic indicates if panics should be recovered.
					recoverPanic?: bool
				}

				// FeatureGates define provider specific feature flags that will
				// be passed
				// in as container args to the provider's controller manager.
				// Controller Manager flag is --feature-gates.
				featureGates?: {
					[string]: bool
				}

				// GracefulShutdownTimeout is the duration given to runnable to
				// stop before the manager actually returns on stop.
				// To disable graceful shutdown, set to time.Duration(0)
				// To use graceful shutdown without timeout, set to a negative
				// duration, e.G. time.Duration(-1)
				// The graceful shutdown is skipped for safety reasons in case the
				// leader election lease is lost.
				gracefulShutDown?: string

				// Health contains the controller health configuration
				health?: {
					// HealthProbeBindAddress is the TCP address that the controller
					// should bind to
					// for serving health probes
					// It can be set to "0" or "" to disable serving the health probe.
					healthProbeBindAddress?: string

					// LivenessEndpointName, defaults to "healthz"
					livenessEndpointName?: string

					// ReadinessEndpointName, defaults to "readyz"
					readinessEndpointName?: string
				}

				// LeaderElection is the LeaderElection config to be used when
				// configuring
				// the manager.Manager leader election
				leaderElection?: {
					// leaderElect enables a leader election client to gain leadership
					// before executing the main loop. Enable this when running
					// replicated
					// components for high availability.
					leaderElect!: bool

					// leaseDuration is the duration that non-leader candidates will
					// wait
					// after observing a leadership renewal until attempting to
					// acquire
					// leadership of a led but unrenewed leader slot. This is
					// effectively the
					// maximum duration that a leader can be stopped before it is
					// replaced
					// by another candidate. This is only applicable if leader
					// election is
					// enabled.
					leaseDuration!: string

					// renewDeadline is the interval between attempts by the acting
					// master to
					// renew a leadership slot before it stops leading. This must be
					// less
					// than or equal to the lease duration. This is only applicable if
					// leader
					// election is enabled.
					renewDeadline!: string

					// resourceLock indicates the resource object type that will be
					// used to lock
					// during leader election cycles.
					resourceLock!: string

					// resourceName indicates the name of resource object that will be
					// used to lock
					// during leader election cycles.
					resourceName!: string

					// resourceName indicates the namespace of resource object that
					// will be used to lock
					// during leader election cycles.
					resourceNamespace!: string

					// retryPeriod is the duration the clients should wait between
					// attempting
					// acquisition and renewal of a leadership. This is only
					// applicable if
					// leader election is enabled.
					retryPeriod!: string
				}

				// MaxConcurrentReconciles is the maximum number of concurrent
				// Reconciles
				// which can be run.
				maxConcurrentReconciles?: int & >=1
				metrics?: {
					// BindAddress is the TCP address that the controller should bind
					// to
					// for serving prometheus metrics.
					// It can be set to "0" to disable the metrics serving.
					bindAddress?: string
				}

				// ProfilerAddress defines the bind address to expose the pprof
				// profiler (e.g. localhost:6060).
				// Default empty, meaning the profiler is disabled.
				// Controller Manager flag is --profiler-address.
				profilerAddress?: string

				// SyncPeriod determines the minimum frequency at which watched
				// resources are
				// reconciled. A lower period will correct entropy more quickly,
				// but reduce
				// responsiveness to change if there are many watched resources.
				// Change this
				// value only if you know what you are doing. Defaults to 10 hours
				// if unset.
				// there will a 10 percent jitter between the SyncPeriod of all
				// controllers
				// so that all controllers will not send list requests
				// simultaneously.
				syncPeriod?: string

				// Verbosity set the logs verbosity. Defaults to 1.
				// Controller Manager flag is --verbosity.
				verbosity?: int & >=0

				// Webhook contains the controllers webhook configuration
				webhook?: {
					// CertDir is the directory that contains the server key and
					// certificate.
					// if not set, webhook server would look up the server key and
					// certificate in
					// {TempDir}/k8s-webhook-server/serving-certs. The server key and
					// certificate
					// must be named tls.key and tls.crt, respectively.
					certDir?: string

					// Host is the hostname that the webhook server binds to.
					// It is used to set webhook.Server.Host.
					host?: string

					// Port is the port that the webhook server serves at.
					// It is used to set webhook.Server.Port.
					port?: int
				}
			}
		}
	}

	// AdditionalManifests is reference to configmap that contains
	// additional manifests that will be applied
	// together with the provider components. The key for storing
	// these manifests has to be `manifests`.
	// The manifests are applied only once when a certain release is
	// installed/upgraded. If namespace is not specified, the
	// namespace of the provider will be used. There is no validation
	// of the yaml content inside the configmap.
	additionalManifests?: {
		// Name defines the name of the configmap.
		name!: string

		// Namespace defines the namespace of the configmap.
		namespace?: string
	}

	// ConfigSecret is the object with name and namespace of the
	// Secret providing
	// the configuration variables for the current provider instance,
	// like e.g. credentials.
	// Such configurations will be used when creating or upgrading
	// provider components.
	// The contents of the secret will be treated as immutable. If
	// changes need
	// to be made, a new object can be created and the name should be
	// updated.
	// The contents should be in the form of key:value. This secret
	// must be in
	// the same namespace as the provider.
	configSecret?: {
		// Name defines the name of the secret.
		name!: string

		// Namespace defines the namespace of the secret.
		namespace?: string
	}

	// Deployment defines the properties that can be enabled on the
	// deployment for the provider.
	deployment?: {
		// If specified, the pod's scheduling constraints
		affinity?: {
			// Describes node affinity scheduling rules for the pod.
			nodeAffinity?: {
				// The scheduler will prefer to schedule pods to nodes that
				// satisfy
				// the affinity expressions specified by this field, but it may
				// choose
				// a node that violates one or more of the expressions. The node
				// that is
				// most preferred is the one with the greatest sum of weights,
				// i.e.
				// for each node that meets all of the scheduling requirements
				// (resource
				// request, requiredDuringScheduling affinity expressions, etc.),
				// compute a sum by iterating through the elements of this field
				// and adding
				// "weight" to the sum if the node matches the corresponding
				// matchExpressions; the
				// node(s) with the highest sum are the most preferred.
				preferredDuringSchedulingIgnoredDuringExecution?: [...{
					// A node selector term, associated with the corresponding weight.
					preference!: {
						// A list of node selector requirements by node's labels.
						matchExpressions?: [...{
							// The label key that the selector applies to.
							key!: string

							// Represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
							// Lt.
							operator!: string

							// An array of string values. If the operator is In or NotIn,
							// the values array must be non-empty. If the operator is Exists
							// or DoesNotExist,
							// the values array must be empty. If the operator is Gt or Lt,
							// the values
							// array must have a single element, which will be interpreted as
							// an integer.
							// This array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// A list of node selector requirements by node's fields.
						matchFields?: [...{
							// The label key that the selector applies to.
							key!: string

							// Represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
							// Lt.
							operator!: string

							// An array of string values. If the operator is In or NotIn,
							// the values array must be non-empty. If the operator is Exists
							// or DoesNotExist,
							// the values array must be empty. If the operator is Gt or Lt,
							// the values
							// array must have a single element, which will be interpreted as
							// an integer.
							// This array is replaced during a strategic merge patch.
							values?: [...string]
						}]
					}

					// Weight associated with matching the corresponding
					// nodeSelectorTerm, in the range 1-100.
					weight!: int32
				}]
				requiredDuringSchedulingIgnoredDuringExecution?: {
					// Required. A list of node selector terms. The terms are ORed.
					nodeSelectorTerms!: [...{
						// A list of node selector requirements by node's labels.
						matchExpressions?: [...{
							// The label key that the selector applies to.
							key!: string

							// Represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
							// Lt.
							operator!: string

							// An array of string values. If the operator is In or NotIn,
							// the values array must be non-empty. If the operator is Exists
							// or DoesNotExist,
							// the values array must be empty. If the operator is Gt or Lt,
							// the values
							// array must have a single element, which will be interpreted as
							// an integer.
							// This array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// A list of node selector requirements by node's fields.
						matchFields?: [...{
							// The label key that the selector applies to.
							key!: string

							// Represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
							// Lt.
							operator!: string

							// An array of string values. If the operator is In or NotIn,
							// the values array must be non-empty. If the operator is Exists
							// or DoesNotExist,
							// the values array must be empty. If the operator is Gt or Lt,
							// the values
							// array must have a single element, which will be interpreted as
							// an integer.
							// This array is replaced during a strategic merge patch.
							values?: [...string]
						}]
					}]
				}
			}

			// Describes pod affinity scheduling rules (e.g. co-locate this
			// pod in the same node, zone, etc. as some other pod(s)).
			podAffinity?: {
				// The scheduler will prefer to schedule pods to nodes that
				// satisfy
				// the affinity expressions specified by this field, but it may
				// choose
				// a node that violates one or more of the expressions. The node
				// that is
				// most preferred is the one with the greatest sum of weights,
				// i.e.
				// for each node that meets all of the scheduling requirements
				// (resource
				// request, requiredDuringScheduling affinity expressions, etc.),
				// compute a sum by iterating through the elements of this field
				// and adding
				// "weight" to the sum if the node has pods which matches the
				// corresponding podAffinityTerm; the
				// node(s) with the highest sum are the most preferred.
				preferredDuringSchedulingIgnoredDuringExecution?: [...{
					// Required. A pod affinity term, associated with the
					// corresponding weight.
					podAffinityTerm!: {
						// A label query over a set of resources, in this case pods.
						// If it's null, this PodAffinityTerm matches with no Pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key!: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator!: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// MatchLabelKeys is a set of pod label keys to select which pods
						// will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// `labelSelector` as `key in (value)`
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both matchLabelKeys and
						// labelSelector.
						// Also, matchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is a beta field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate (enabled by default).
						matchLabelKeys?: [...string]

						// MismatchLabelKeys is a set of pod label keys to select which
						// pods will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// `labelSelector` as `key notin (value)`
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both mismatchLabelKeys
						// and labelSelector.
						// Also, mismatchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is a beta field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate (enabled by default).
						mismatchLabelKeys?: [...string]

						// A label query over the set of namespaces that the term applies
						// to.
						// The term is applied to the union of the namespaces selected by
						// this field
						// and the ones listed in the namespaces field.
						// null selector and null or empty namespaces list means "this
						// pod's namespace".
						// An empty selector ({}) matches all namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key!: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator!: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to.
						// The term is applied to the union of the namespaces listed in
						// this field
						// and the ones selected by namespaceSelector.
						// null or empty namespaces list and null namespaceSelector means
						// "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching
						// the labelSelector in the specified namespaces, where co-located
						// is defined as running on a node
						// whose value of the label with key topologyKey matches that of
						// any node on which any of the
						// selected pods is running.
						// Empty topologyKey is not allowed.
						topologyKey!: string
					}

					// weight associated with matching the corresponding
					// podAffinityTerm,
					// in the range 1-100.
					weight!: int32
				}]

				// If the affinity requirements specified by this field are not
				// met at
				// scheduling time, the pod will not be scheduled onto the node.
				// If the affinity requirements specified by this field cease to
				// be met
				// at some point during pod execution (e.g. due to a pod label
				// update), the
				// system may or may not try to eventually evict the pod from its
				// node.
				// When there are multiple elements, the lists of nodes
				// corresponding to each
				// podAffinityTerm are intersected, i.e. all terms must be
				// satisfied.
				requiredDuringSchedulingIgnoredDuringExecution?: [...{
					// A label query over a set of resources, in this case pods.
					// If it's null, this PodAffinityTerm matches with no Pods.
					labelSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key!: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator!: string

							// values is an array of string values. If the operator is In or
							// NotIn,
							// the values array must be non-empty. If the operator is Exists
							// or DoesNotExist,
							// the values array must be empty. This array is replaced during a
							// strategic
							// merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels
						// map is equivalent to an element of matchExpressions, whose key
						// field is "key", the
						// operator is "In", and the values array contains only "value".
						// The requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// MatchLabelKeys is a set of pod label keys to select which pods
					// will
					// be taken into consideration. The keys are used to lookup values
					// from the
					// incoming pod labels, those key-value labels are merged with
					// `labelSelector` as `key in (value)`
					// to select the group of existing pods which pods will be taken
					// into consideration
					// for the incoming pod's pod (anti) affinity. Keys that don't
					// exist in the incoming
					// pod labels will be ignored. The default value is empty.
					// The same key is forbidden to exist in both matchLabelKeys and
					// labelSelector.
					// Also, matchLabelKeys cannot be set when labelSelector isn't
					// set.
					// This is a beta field and requires enabling
					// MatchLabelKeysInPodAffinity feature gate (enabled by default).
					matchLabelKeys?: [...string]

					// MismatchLabelKeys is a set of pod label keys to select which
					// pods will
					// be taken into consideration. The keys are used to lookup values
					// from the
					// incoming pod labels, those key-value labels are merged with
					// `labelSelector` as `key notin (value)`
					// to select the group of existing pods which pods will be taken
					// into consideration
					// for the incoming pod's pod (anti) affinity. Keys that don't
					// exist in the incoming
					// pod labels will be ignored. The default value is empty.
					// The same key is forbidden to exist in both mismatchLabelKeys
					// and labelSelector.
					// Also, mismatchLabelKeys cannot be set when labelSelector isn't
					// set.
					// This is a beta field and requires enabling
					// MatchLabelKeysInPodAffinity feature gate (enabled by default).
					mismatchLabelKeys?: [...string]

					// A label query over the set of namespaces that the term applies
					// to.
					// The term is applied to the union of the namespaces selected by
					// this field
					// and the ones listed in the namespaces field.
					// null selector and null or empty namespaces list means "this
					// pod's namespace".
					// An empty selector ({}) matches all namespaces.
					namespaceSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key!: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator!: string

							// values is an array of string values. If the operator is In or
							// NotIn,
							// the values array must be non-empty. If the operator is Exists
							// or DoesNotExist,
							// the values array must be empty. This array is replaced during a
							// strategic
							// merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels
						// map is equivalent to an element of matchExpressions, whose key
						// field is "key", the
						// operator is "In", and the values array contains only "value".
						// The requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// namespaces specifies a static list of namespace names that the
					// term applies to.
					// The term is applied to the union of the namespaces listed in
					// this field
					// and the ones selected by namespaceSelector.
					// null or empty namespaces list and null namespaceSelector means
					// "this pod's namespace".
					namespaces?: [...string]

					// This pod should be co-located (affinity) or not co-located
					// (anti-affinity) with the pods matching
					// the labelSelector in the specified namespaces, where co-located
					// is defined as running on a node
					// whose value of the label with key topologyKey matches that of
					// any node on which any of the
					// selected pods is running.
					// Empty topologyKey is not allowed.
					topologyKey!: string
				}]
			}

			// Describes pod anti-affinity scheduling rules (e.g. avoid
			// putting this pod in the same node, zone, etc. as some other
			// pod(s)).
			podAntiAffinity?: {
				// The scheduler will prefer to schedule pods to nodes that
				// satisfy
				// the anti-affinity expressions specified by this field, but it
				// may choose
				// a node that violates one or more of the expressions. The node
				// that is
				// most preferred is the one with the greatest sum of weights,
				// i.e.
				// for each node that meets all of the scheduling requirements
				// (resource
				// request, requiredDuringScheduling anti-affinity expressions,
				// etc.),
				// compute a sum by iterating through the elements of this field
				// and adding
				// "weight" to the sum if the node has pods which matches the
				// corresponding podAffinityTerm; the
				// node(s) with the highest sum are the most preferred.
				preferredDuringSchedulingIgnoredDuringExecution?: [...{
					// Required. A pod affinity term, associated with the
					// corresponding weight.
					podAffinityTerm!: {
						// A label query over a set of resources, in this case pods.
						// If it's null, this PodAffinityTerm matches with no Pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key!: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator!: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// MatchLabelKeys is a set of pod label keys to select which pods
						// will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// `labelSelector` as `key in (value)`
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both matchLabelKeys and
						// labelSelector.
						// Also, matchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is a beta field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate (enabled by default).
						matchLabelKeys?: [...string]

						// MismatchLabelKeys is a set of pod label keys to select which
						// pods will
						// be taken into consideration. The keys are used to lookup values
						// from the
						// incoming pod labels, those key-value labels are merged with
						// `labelSelector` as `key notin (value)`
						// to select the group of existing pods which pods will be taken
						// into consideration
						// for the incoming pod's pod (anti) affinity. Keys that don't
						// exist in the incoming
						// pod labels will be ignored. The default value is empty.
						// The same key is forbidden to exist in both mismatchLabelKeys
						// and labelSelector.
						// Also, mismatchLabelKeys cannot be set when labelSelector isn't
						// set.
						// This is a beta field and requires enabling
						// MatchLabelKeysInPodAffinity feature gate (enabled by default).
						mismatchLabelKeys?: [...string]

						// A label query over the set of namespaces that the term applies
						// to.
						// The term is applied to the union of the namespaces selected by
						// this field
						// and the ones listed in the namespaces field.
						// null selector and null or empty namespaces list means "this
						// pod's namespace".
						// An empty selector ({}) matches all namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key!: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator!: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to.
						// The term is applied to the union of the namespaces listed in
						// this field
						// and the ones selected by namespaceSelector.
						// null or empty namespaces list and null namespaceSelector means
						// "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching
						// the labelSelector in the specified namespaces, where co-located
						// is defined as running on a node
						// whose value of the label with key topologyKey matches that of
						// any node on which any of the
						// selected pods is running.
						// Empty topologyKey is not allowed.
						topologyKey!: string
					}

					// weight associated with matching the corresponding
					// podAffinityTerm,
					// in the range 1-100.
					weight!: int32
				}]

				// If the anti-affinity requirements specified by this field are
				// not met at
				// scheduling time, the pod will not be scheduled onto the node.
				// If the anti-affinity requirements specified by this field cease
				// to be met
				// at some point during pod execution (e.g. due to a pod label
				// update), the
				// system may or may not try to eventually evict the pod from its
				// node.
				// When there are multiple elements, the lists of nodes
				// corresponding to each
				// podAffinityTerm are intersected, i.e. all terms must be
				// satisfied.
				requiredDuringSchedulingIgnoredDuringExecution?: [...{
					// A label query over a set of resources, in this case pods.
					// If it's null, this PodAffinityTerm matches with no Pods.
					labelSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key!: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator!: string

							// values is an array of string values. If the operator is In or
							// NotIn,
							// the values array must be non-empty. If the operator is Exists
							// or DoesNotExist,
							// the values array must be empty. This array is replaced during a
							// strategic
							// merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels
						// map is equivalent to an element of matchExpressions, whose key
						// field is "key", the
						// operator is "In", and the values array contains only "value".
						// The requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// MatchLabelKeys is a set of pod label keys to select which pods
					// will
					// be taken into consideration. The keys are used to lookup values
					// from the
					// incoming pod labels, those key-value labels are merged with
					// `labelSelector` as `key in (value)`
					// to select the group of existing pods which pods will be taken
					// into consideration
					// for the incoming pod's pod (anti) affinity. Keys that don't
					// exist in the incoming
					// pod labels will be ignored. The default value is empty.
					// The same key is forbidden to exist in both matchLabelKeys and
					// labelSelector.
					// Also, matchLabelKeys cannot be set when labelSelector isn't
					// set.
					// This is a beta field and requires enabling
					// MatchLabelKeysInPodAffinity feature gate (enabled by default).
					matchLabelKeys?: [...string]

					// MismatchLabelKeys is a set of pod label keys to select which
					// pods will
					// be taken into consideration. The keys are used to lookup values
					// from the
					// incoming pod labels, those key-value labels are merged with
					// `labelSelector` as `key notin (value)`
					// to select the group of existing pods which pods will be taken
					// into consideration
					// for the incoming pod's pod (anti) affinity. Keys that don't
					// exist in the incoming
					// pod labels will be ignored. The default value is empty.
					// The same key is forbidden to exist in both mismatchLabelKeys
					// and labelSelector.
					// Also, mismatchLabelKeys cannot be set when labelSelector isn't
					// set.
					// This is a beta field and requires enabling
					// MatchLabelKeysInPodAffinity feature gate (enabled by default).
					mismatchLabelKeys?: [...string]

					// A label query over the set of namespaces that the term applies
					// to.
					// The term is applied to the union of the namespaces selected by
					// this field
					// and the ones listed in the namespaces field.
					// null selector and null or empty namespaces list means "this
					// pod's namespace".
					// An empty selector ({}) matches all namespaces.
					namespaceSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key!: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator!: string

							// values is an array of string values. If the operator is In or
							// NotIn,
							// the values array must be non-empty. If the operator is Exists
							// or DoesNotExist,
							// the values array must be empty. This array is replaced during a
							// strategic
							// merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels
						// map is equivalent to an element of matchExpressions, whose key
						// field is "key", the
						// operator is "In", and the values array contains only "value".
						// The requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// namespaces specifies a static list of namespace names that the
					// term applies to.
					// The term is applied to the union of the namespaces listed in
					// this field
					// and the ones selected by namespaceSelector.
					// null or empty namespaces list and null namespaceSelector means
					// "this pod's namespace".
					namespaces?: [...string]

					// This pod should be co-located (affinity) or not co-located
					// (anti-affinity) with the pods matching
					// the labelSelector in the specified namespaces, where co-located
					// is defined as running on a node
					// whose value of the label with key topologyKey matches that of
					// any node on which any of the
					// selected pods is running.
					// Empty topologyKey is not allowed.
					topologyKey!: string
				}]
			}
		}

		// List of containers specified in the Deployment
		containers?: [...{
			// Args represents extra provider specific flags that are not
			// encoded as fields in this API.
			// Explicit controller manager properties defined in the
			// `Provider.ManagerSpec`
			// will have higher precedence than those defined in
			// `ContainerSpec.Args`.
			// For example, `ManagerSpec.SyncPeriod` will be used instead of
			// the
			// container arg `--sync-period` if both are defined.
			// The same holds for `ManagerSpec.FeatureGates` and
			// `--feature-gates`.
			args?: {
				[string]: string
			}

			// Command allows override container's entrypoint array.
			command?: [...string]

			// List of environment variables to set in the container.
			env?: [...{
				// Name of the environment variable. Must be a C_IDENTIFIER.
				name!: string

				// Variable references $(VAR_NAME) are expanded
				// using the previously defined environment variables in the
				// container and
				// any service environment variables. If a variable cannot be
				// resolved,
				// the reference in the input string will be unchanged. Double $$
				// are reduced
				// to a single $, which allows for escaping the $(VAR_NAME)
				// syntax: i.e.
				// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
				// Escaped references will never be expanded, regardless of
				// whether the variable
				// exists or not.
				// Defaults to "".
				value?: string

				// Source for the environment variable's value. Cannot be used if
				// value is not empty.
				valueFrom?: {
					// Selects a key of a ConfigMap.
					configMapKeyRef?: {
						// The key to select.
						key!: string

						// Name of the referent.
						// This field is effectively required, but due to backwards
						// compatibility is
						// allowed to be empty. Instances of this type with an empty value
						// here are
						// almost certainly wrong.
						// More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// Specify whether the ConfigMap or its key must be defined
						optional?: bool
					}

					// Selects a field of the pod: supports metadata.name,
					// metadata.namespace, `metadata.labels['<KEY>']`,
					// `metadata.annotations['<KEY>']`,
					// spec.nodeName, spec.serviceAccountName, status.hostIP,
					// status.podIP, status.podIPs.
					fieldRef?: {
						// Version of the schema the FieldPath is written in terms of,
						// defaults to "v1".
						apiVersion?: string

						// Path of the field to select in the specified API version.
						fieldPath!: string
					}

					// Selects a resource of the container: only resources limits and
					// requests
					// (limits.cpu, limits.memory, limits.ephemeral-storage,
					// requests.cpu, requests.memory and requests.ephemeral-storage)
					// are currently supported.
					resourceFieldRef?: {
						// Container name: required for volumes, optional for env vars
						containerName?: string

						// Specifies the output format of the exposed resources, defaults
						// to "1"
						divisor?: matchN(>=1, [int, string]) & (number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$")

						// Required: resource to select
						resource!: string
					}

					// Selects a key of a secret in the pod's namespace
					secretKeyRef?: {
						// The key of the secret to select from. Must be a valid secret
						// key.
						key!: string

						// Name of the referent.
						// This field is effectively required, but due to backwards
						// compatibility is
						// allowed to be empty. Instances of this type with an empty value
						// here are
						// almost certainly wrong.
						// More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// Specify whether the Secret or its key must be defined
						optional?: bool
					}
				}
			}]

			// Container Image URL
			imageUrl?: string

			// Name of the container. Cannot be updated.
			name!: string

			// Compute resources required by this container.
			resources?: {
				// Claims lists the names of resources, defined in
				// spec.resourceClaims,
				// that are used by this container.
				//
				// This is an alpha field and requires enabling the
				// DynamicResourceAllocation feature gate.
				//
				// This field is immutable. It can only be set for containers.
				claims?: [...{
					// Name must match the name of one entry in
					// pod.spec.resourceClaims of
					// the Pod where this field is used. It makes that resource
					// available
					// inside a container.
					name!: string

					// Request is the name chosen for a request in the referenced
					// claim.
					// If empty, everything from the claim is made available,
					// otherwise
					// only the result of this request.
					request?: string
				}]

				// Limits describes the maximum amount of compute resources
				// allowed.
				// More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				limits?: {
					[string]: matchN(>=1, [int, string]) & (number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$")
				}

				// Requests describes the minimum amount of compute resources
				// required.
				// If Requests is omitted for a container, it defaults to Limits
				// if that is explicitly specified,
				// otherwise to an implementation-defined value. Requests cannot
				// exceed Limits.
				// More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				requests?: {
					[string]: matchN(>=1, [int, string]) & (number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$")
				}
			}
		}]

		// List of image pull secrets specified in the Deployment
		imagePullSecrets?: [...{
			// Name of the referent.
			// This field is effectively required, but due to backwards
			// compatibility is
			// allowed to be empty. Instances of this type with an empty value
			// here are
			// almost certainly wrong.
			// More info:
			// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			name?: string
		}]

		// NodeSelector is a selector which must be true for the pod to
		// fit on a node.
		// Selector which must match a node's labels for the pod to be
		// scheduled on that node.
		// More info:
		// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
		nodeSelector?: {
			[string]: string
		}

		// Number of desired pods. This is a pointer to distinguish
		// between explicit zero and not specified. Defaults to 1.
		replicas?: int & >=0

		// If specified, the pod's service account
		serviceAccountName?: string

		// If specified, the pod's tolerations.
		tolerations?: [...{
			// Effect indicates the taint effect to match. Empty means match
			// all taint effects.
			// When specified, allowed values are NoSchedule, PreferNoSchedule
			// and NoExecute.
			effect?: string

			// Key is the taint key that the toleration applies to. Empty
			// means match all taint keys.
			// If the key is empty, operator must be Exists; this combination
			// means to match all values and all keys.
			key?: string

			// Operator represents a key's relationship to the value.
			// Valid operators are Exists and Equal. Defaults to Equal.
			// Exists is equivalent to wildcard for value, so that a pod can
			// tolerate all taints of a particular category.
			operator?: string

			// TolerationSeconds represents the period of time the toleration
			// (which must be
			// of effect NoExecute, otherwise this field is ignored) tolerates
			// the taint. By default,
			// it is not set, which means tolerate the taint forever (do not
			// evict). Zero and
			// negative values will be treated as 0 (evict immediately) by the
			// system.
			tolerationSeconds?: int64

			// Value is the taint value the toleration matches to.
			// If the operator is Exists, the value should be empty, otherwise
			// just a regular string.
			value?: string
		}]
	}

	// FetchConfig determines how the operator will fetch the
	// components and metadata for the provider.
	// If nil, the operator will try to fetch components according to
	// default
	// embedded fetch configuration for the given kind and
	// `ObjectMeta.Name`.
	// For example, the infrastructure name `aws` will fetch artifacts
	// from
	// https://github.com/kubernetes-sigs/cluster-api-provider-aws/releases.
	fetchConfig?: {
		// OCI to be used for fetching the provider’s components and
		// metadata from an OCI artifact.
		// You must set `providerSpec.Version` field for operator to pick
		// up desired version of the release from GitHub.
		// If the providerSpec.Version is missing, latest provider version
		// from clusterctl defaults is used.
		oci?: string

		// Selector to be used for fetching provider’s components and
		// metadata from
		// ConfigMaps stored inside the cluster. Each ConfigMap is
		// expected to contain
		// components and metadata for a specific version only.
		// Note: the name of the ConfigMap should be set to the version or
		// to override this
		// add a label like the following:
		// provider.cluster.x-k8s.io/version=v1.4.3
		selector?: {
			// matchExpressions is a list of label selector requirements. The
			// requirements are ANDed.
			matchExpressions?: [...{
				// key is the label key that the selector applies to.
				key!: string

				// operator represents a key's relationship to a set of values.
				// Valid operators are In, NotIn, Exists and DoesNotExist.
				operator!: string

				// values is an array of string values. If the operator is In or
				// NotIn,
				// the values array must be non-empty. If the operator is Exists
				// or DoesNotExist,
				// the values array must be empty. This array is replaced during a
				// strategic
				// merge patch.
				values?: [...string]
			}]

			// matchLabels is a map of {key,value} pairs. A single {key,value}
			// in the matchLabels
			// map is equivalent to an element of matchExpressions, whose key
			// field is "key", the
			// operator is "In", and the values array contains only "value".
			// The requirements are ANDed.
			matchLabels?: {
				[string]: string
			}
		}

		// URL to be used for fetching the provider’s components and
		// metadata from a remote Github repository.
		// For example, https://github.com/{owner}/{repository}/releases
		// You must set `providerSpec.Version` field for operator to pick
		// up
		// desired version of the release from GitHub.
		url?: string
	}

	// Manager defines the properties that can be enabled on the
	// controller manager for the provider.
	manager?: {
		// AdditionalArgs is a map of additional options that will be
		// passed
		// in as container args to the provider's controller manager.
		additionalArgs?: {
			[string]: string
		}

		// CacheNamespace if specified restricts the manager's cache to
		// watch objects in
		// the desired namespace Defaults to all namespaces
		//
		// Note: If a namespace is specified, controllers can still Watch
		// for a
		// cluster-scoped resource (e.g Node). For namespaced resources
		// the cache
		// will only hold objects from the desired namespace.
		cacheNamespace?: string

		// Controller contains global configuration options for
		// controllers
		// registered within this manager.
		controller?: {
			// CacheSyncTimeout refers to the time limit set to wait for
			// syncing caches.
			// Defaults to 2 minutes if not set.
			cacheSyncTimeout?: int64

			// GroupKindConcurrency is a map from a Kind to the number of
			// concurrent reconciliation
			// allowed for that controller.
			//
			// When a controller is registered within this manager using the
			// builder utilities,
			// users have to specify the type the controller reconciles in the
			// For(...) call.
			// If the object's kind passed matches one of the keys in this
			// map, the concurrency
			// for that controller is set to the number specified.
			//
			// The key is expected to be consistent in form with
			// GroupKind.String(),
			// e.g. ReplicaSet in apps group (regardless of version) would be
			// `ReplicaSet.apps`.
			groupKindConcurrency?: {
				[string]: int
			}

			// RecoverPanic indicates if panics should be recovered.
			recoverPanic?: bool
		}

		// FeatureGates define provider specific feature flags that will
		// be passed
		// in as container args to the provider's controller manager.
		// Controller Manager flag is --feature-gates.
		featureGates?: {
			[string]: bool
		}

		// GracefulShutdownTimeout is the duration given to runnable to
		// stop before the manager actually returns on stop.
		// To disable graceful shutdown, set to time.Duration(0)
		// To use graceful shutdown without timeout, set to a negative
		// duration, e.G. time.Duration(-1)
		// The graceful shutdown is skipped for safety reasons in case the
		// leader election lease is lost.
		gracefulShutDown?: string

		// Health contains the controller health configuration
		health?: {
			// HealthProbeBindAddress is the TCP address that the controller
			// should bind to
			// for serving health probes
			// It can be set to "0" or "" to disable serving the health probe.
			healthProbeBindAddress?: string

			// LivenessEndpointName, defaults to "healthz"
			livenessEndpointName?: string

			// ReadinessEndpointName, defaults to "readyz"
			readinessEndpointName?: string
		}

		// LeaderElection is the LeaderElection config to be used when
		// configuring
		// the manager.Manager leader election
		leaderElection?: {
			// leaderElect enables a leader election client to gain leadership
			// before executing the main loop. Enable this when running
			// replicated
			// components for high availability.
			leaderElect!: bool

			// leaseDuration is the duration that non-leader candidates will
			// wait
			// after observing a leadership renewal until attempting to
			// acquire
			// leadership of a led but unrenewed leader slot. This is
			// effectively the
			// maximum duration that a leader can be stopped before it is
			// replaced
			// by another candidate. This is only applicable if leader
			// election is
			// enabled.
			leaseDuration!: string

			// renewDeadline is the interval between attempts by the acting
			// master to
			// renew a leadership slot before it stops leading. This must be
			// less
			// than or equal to the lease duration. This is only applicable if
			// leader
			// election is enabled.
			renewDeadline!: string

			// resourceLock indicates the resource object type that will be
			// used to lock
			// during leader election cycles.
			resourceLock!: string

			// resourceName indicates the name of resource object that will be
			// used to lock
			// during leader election cycles.
			resourceName!: string

			// resourceName indicates the namespace of resource object that
			// will be used to lock
			// during leader election cycles.
			resourceNamespace!: string

			// retryPeriod is the duration the clients should wait between
			// attempting
			// acquisition and renewal of a leadership. This is only
			// applicable if
			// leader election is enabled.
			retryPeriod!: string
		}

		// MaxConcurrentReconciles is the maximum number of concurrent
		// Reconciles
		// which can be run.
		maxConcurrentReconciles?: int & >=1
		metrics?: {
			// BindAddress is the TCP address that the controller should bind
			// to
			// for serving prometheus metrics.
			// It can be set to "0" to disable the metrics serving.
			bindAddress?: string
		}

		// ProfilerAddress defines the bind address to expose the pprof
		// profiler (e.g. localhost:6060).
		// Default empty, meaning the profiler is disabled.
		// Controller Manager flag is --profiler-address.
		profilerAddress?: string

		// SyncPeriod determines the minimum frequency at which watched
		// resources are
		// reconciled. A lower period will correct entropy more quickly,
		// but reduce
		// responsiveness to change if there are many watched resources.
		// Change this
		// value only if you know what you are doing. Defaults to 10 hours
		// if unset.
		// there will a 10 percent jitter between the SyncPeriod of all
		// controllers
		// so that all controllers will not send list requests
		// simultaneously.
		syncPeriod?: string

		// Verbosity set the logs verbosity. Defaults to 1.
		// Controller Manager flag is --verbosity.
		verbosity?: int & >=0

		// Webhook contains the controllers webhook configuration
		webhook?: {
			// CertDir is the directory that contains the server key and
			// certificate.
			// if not set, webhook server would look up the server key and
			// certificate in
			// {TempDir}/k8s-webhook-server/serving-certs. The server key and
			// certificate
			// must be named tls.key and tls.crt, respectively.
			certDir?: string

			// Host is the hostname that the webhook server binds to.
			// It is used to set webhook.Server.Host.
			host?: string

			// Port is the port that the webhook server serves at.
			// It is used to set webhook.Server.Port.
			port?: int
		}
	}

	// ManifestPatches are applied to rendered provider manifests to
	// customize the
	// provider manifests. Patches are applied in the order they are
	// specified.
	// The `kind` field must match the target object, and
	// if `apiVersion` is specified it will only be applied to
	// matching objects.
	// This should be an inline yaml blob-string
	// https://datatracker.ietf.org/doc/html/rfc7396
	manifestPatches?: [...string]

	// Version indicates the provider version.
	version?: string
}
