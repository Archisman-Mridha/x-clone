// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f /tmp/kue/cluster-api-provider-aws/config/crd/bases/controlplane.cluster.x-k8s.io_rosacontrolplanes.yaml

package v1beta2

import (
	"strings"
	"list"
)

// ROSAControlPlane is the Schema for the ROSAControlPlanes API.
#ROSAControlPlane: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "controlplane.cluster.x-k8s.io/v1beta2"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "ROSAControlPlane"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// RosaControlPlaneSpec defines the desired state of
	// ROSAControlPlane.
	spec!: #ROSAControlPlaneSpec
}

// RosaControlPlaneSpec defines the desired state of
// ROSAControlPlane.
#ROSAControlPlaneSpec: {
	// AdditionalTags are user-defined tags to be added on the AWS
	// resources associated with the control plane.
	additionalTags?: {
		[string]: string
	}

	// AuditLogRoleARN defines the role that is used to forward audit
	// logs to AWS CloudWatch.
	// If not set, audit log forwarding is disabled.
	auditLogRoleARN?: string

	// AvailabilityZones describe AWS AvailabilityZones of the worker
	// nodes.
	// should match the AvailabilityZones of the provided Subnets.
	// a machinepool will be created for each availabilityZone.
	availabilityZones!: [...string]

	// BillingAccount is an optional AWS account to use for billing
	// the subscription fees for ROSA HCP clusters.
	// The cost of running each ROSA HCP cluster will be billed to the
	// infrastructure account in which the cluster
	// is running.
	billingAccount?: string

	// OpenShift version channel group, default is stable.
	channelGroup!: "stable" | "fast" | "candidate" | "nightly"

	// ClusterRegistryConfig represents registry config used with the
	// cluster.
	clusterRegistryConfig?: {
		// AdditionalTrustedCAs containing the registry hostname as the
		// key, and the PEM-encoded certificate as the value,
		// for each additional registry CA to trust.
		additionalTrustedCAs?: {
			[string]: string
		}

		// AllowedRegistriesForImport limits the container image
		// registries that normal users may import
		// images from. Set this list to the registries that you trust to
		// contain valid Docker
		// images and that you want applications to be able to import
		// from.
		allowedRegistriesForImport?: [...{
			// domainName specifies a domain name for the registry. The domain
			// name might include wildcards, like '*' or '??'.
			// In case the registry use non-standard (80 or 443) port, the
			// port should be included in the domain name as well.
			domainName?: string

			// insecure indicates whether the registry is secure (https) or
			// insecure (http), default is secured.
			insecure?: bool
		}]

		// RegistrySources contains configuration that determines how the
		// container runtime
		// should treat individual registries when accessing images. It
		// does not contain configuration
		// for the internal cluster registry. AllowedRegistries,
		// BlockedRegistries are mutually exclusive.
		registrySources?: {
			// AllowedRegistries are the registries for which image pull and
			// push actions are allowed.
			// To specify all subdomains, add the asterisk (*) wildcard
			// character as a prefix to the domain name,
			// For example, *.example.com.
			// You can specify an individual repository within a registry, For
			// example: reg1.io/myrepo/myapp:latest.
			// All other registries are blocked.
			allowedRegistries?: [...string]

			// BlockedRegistries are the registries for which image pull and
			// push actions are denied.
			// To specify all subdomains, add the asterisk (*) wildcard
			// character as a prefix to the domain name,
			// For example, *.example.com.
			// You can specify an individual repository within a registry, For
			// example: reg1.io/myrepo/myapp:latest.
			// All other registries are allowed.
			blockedRegistries?: [...string]

			// InsecureRegistries are registries which do not have a valid TLS
			// certificate or only support HTTP connections.
			// To specify all subdomains, add the asterisk (*) wildcard
			// character as a prefix to the domain name,
			// For example, *.example.com.
			// You can specify an individual repository within a registry, For
			// example: reg1.io/myrepo/myapp:latest.
			insecureRegistries?: [...string]
		}
	}

	// ControlPlaneEndpoint represents the endpoint used to
	// communicate with the control plane.
	controlPlaneEndpoint?: {
		// host is the hostname on which the API server is serving.
		host!: strings.MaxRunes(512)

		// port is the port on which the API server is serving.
		port!: int32
	}
	credentialsSecretRef?: {
		// Name of the referent.
		// This field is effectively required, but due to backwards
		// compatibility is
		// allowed to be empty. Instances of this type with an empty value
		// here are
		// almost certainly wrong.
		// More info:
		// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
		name?: string
	}

	// DefaultMachinePoolSpec defines the configuration for the
	// default machinepool(s) provisioned as part of the cluster
	// creation.
	// One MachinePool will be created with this configuration per
	// AvailabilityZone. Those default machinepools are required for
	// openshift cluster operators
	// to work properly.
	// As these machinepool not created using ROSAMachinePool CR, they
	// will not be visible/managed by ROSA CAPI provider.
	// `rosa list machinepools -c <rosaClusterName>` can be used to
	// view those machinepools.
	//
	// This field will be removed in the future once the current
	// limitation is resolved.
	defaultMachinePoolSpec?: {
		// Autoscaling specifies auto scaling behaviour for the default
		// MachinePool. Autoscaling min/max value
		// must be equal or multiple of the availability zones count.
		autoscaling?: {
			maxReplicas?: int & >=1
			minReplicas?: int & >=1
		}

		// The instance type to use, for example `r5.xlarge`. Instance
		// type ref; https://aws.amazon.com/ec2/instance-types/
		instanceType?: string

		// VolumeSize set the disk volume size for the default workers
		// machine pool in Gib. The default is 300 GiB.
		volumeSize?: uint & >=75 & <=16384
	}

	// DomainPrefix is an optional prefix added to the cluster's
	// domain name. It will be used
	// when generating a sub-domain for the cluster on openshiftapps
	// domain. It must be valid DNS-1035 label
	// consisting of lower case alphanumeric characters or '-', start
	// with an alphabetic character
	// end with an alphanumeric character and have a max length of 15
	// characters.
	domainPrefix?: strings.MaxRunes(15) & {
		=~"^[a-z]([-a-z0-9]*[a-z0-9])?$"
	}

	// EnableExternalAuthProviders enables external authentication
	// configuration for the cluster.
	enableExternalAuthProviders?: bool

	// EndpointAccess specifies the publishing scope of cluster
	// endpoints. The
	// default is Public.
	endpointAccess?: "Public" | "Private"

	// EtcdEncryptionKMSARN is the ARN of the KMS key used to encrypt
	// etcd. The key itself needs to be
	// created out-of-band by the user and tagged with `red-hat:true`.
	etcdEncryptionKMSARN?: string

	// ExternalAuthProviders are external OIDC identity providers that
	// can issue tokens for this cluster.
	// Can only be set if "enableExternalAuthProviders" is set to
	// "True".
	//
	// At most one provider can be configured.
	externalAuthProviders?: list.MaxItems(1) & [...{
		// ClaimMappings describes rules on how to transform information
		// from an
		// ID token into a cluster identity
		claimMappings?: {
			// Groups is a name of the claim that should be used to construct
			// groups for the cluster identity.
			// The referenced claim must use array of strings values.
			groups?: {
				// Claim is a JWT token claim to be used in the mapping
				claim!: string

				// Prefix is a string to prefix the value from the token in the
				// result of the
				// claim mapping.
				//
				// By default, no prefixing occurs.
				//
				// Example: if `prefix` is set to "myoidc:"" and the `claim` in
				// JWT contains
				// an array of strings "a", "b" and "c", the mapping will result
				// in an
				// array of string "myoidc:a", "myoidc:b" and "myoidc:c".
				prefix?: string
			}

			// Username is a name of the claim that should be used to
			// construct
			// usernames for the cluster identity.
			//
			// Default value: "sub"
			username?: {
				// Claim is a JWT token claim to be used in the mapping
				claim!: string

				// Prefix is prepended to claim to prevent clashes with existing
				// names.
				prefix?: strings.MinRunes(1)

				// PrefixPolicy specifies how a prefix should apply.
				//
				// By default, claims other than `email` will be prefixed with the
				// issuer URL to
				// prevent naming clashes with other plugins.
				//
				// Set to "NoPrefix" to disable prefixing.
				//
				// Example:
				// (1) `prefix` is set to "myoidc:" and `claim` is set to
				// "username".
				// If the JWT claim `username` contains value `userA`, the
				// resulting
				// mapped value will be "myoidc:userA".
				// (2) `prefix` is set to "myoidc:" and `claim` is set to "email".
				// If the
				// JWT `email` claim contains value "userA@myoidc.tld", the
				// resulting
				// mapped value will be "myoidc:userA@myoidc.tld".
				// (3) `prefix` is unset, `issuerURL` is set to
				// `https://myoidc.tld`,
				// the JWT claims include "username":"userA" and
				// "email":"userA@myoidc.tld",
				// and `claim` is set to:
				// (a) "username": the mapped value will be
				// "https://myoidc.tld#userA"
				// (b) "email": the mapped value will be "userA@myoidc.tld"
				prefixPolicy?: "" | "NoPrefix" | "Prefix"
			}
		}

		// ClaimValidationRules are rules that are applied to validate
		// token claims to authenticate users.
		claimValidationRules?: [...{
			// RequiredClaim allows configuring a required claim name and its
			// expected value
			requiredClaim!: {
				// Claim is a name of a required claim. Only claims with string
				// values are
				// supported.
				claim!: strings.MinRunes(1)

				// RequiredValue is the required value for the claim.
				requiredValue!: strings.MinRunes(1)
			}

			// Type sets the type of the validation rule
			type!: "RequiredClaim"
		}]

		// Issuer describes attributes of the OIDC token issuer
		issuer!: {
			// Audiences is an array of audiences that the token was issued
			// for.
			// Valid tokens must include at least one of these values in their
			// "aud" claim.
			// Must be set to exactly one value.
			audiences!: list.MaxItems(10) & [...strings.MinRunes(1)] & [_, ...]
			issuerCertificateAuthority?: {
				// Name is the metadata.name of the referenced object.
				name!: string
			}

			// URL is the serving URL of the token issuer.
			// Must use the https:// scheme.
			issuerURL!: =~"^https:\\/\\/[^\\s]"
		}

		// Name of the OIDC provider
		name!: strings.MinRunes(1)

		// OIDCClients contains configuration for the platform's clients
		// that
		// need to request tokens from the issuer
		oidcClients?: list.MaxItems(20) & [...{
			// ClientID is the identifier of the OIDC client from the OIDC
			// provider
			clientID!: strings.MinRunes(1)
			clientSecret!: {
				// Name is the metadata.name of the referenced object.
				name!: string
			}

			// ComponentName is the name of the component that is supposed to
			// consume this
			// client configuration
			componentName!: strings.MaxRunes(256) & strings.MinRunes(1)

			// ComponentNamespace is the namespace of the component that is
			// supposed to consume this
			// client configuration
			componentNamespace!: strings.MaxRunes(63) & strings.MinRunes(1)

			// ExtraScopes is an optional set of scopes to request tokens
			// with.
			extraScopes?: [...string]
		}]
	}]

	// IdentityRef is a reference to an identity to be used when
	// reconciling the managed control plane.
	// If no identity is specified, the default identity for this
	// controller will be used.
	identityRef?: {
		// Kind of the identity.
		kind!: "AWSClusterControllerIdentity" | "AWSClusterRoleIdentity" | "AWSClusterStaticIdentity"

		// Name of the identity.
		name!: strings.MinRunes(1)
	}

	// InstallerRoleARN is an AWS IAM role that OpenShift Cluster
	// Manager will assume to create the cluster..
	installerRoleARN!: string

	// Network config for the ROSA HCP cluster.
	network?: {
		// Network host prefix which is defaulted to `23` if not
		// specified.
		hostPrefix?: int

		// IP addresses block used by OpenShift while installing the
		// cluster, for example "10.0.0.0/16".
		machineCIDR?: string

		// The CNI network type default is OVNKubernetes.
		networkType?: "OVNKubernetes" | "Other"

		// IP address block from which to assign pod IP addresses, for
		// example `10.128.0.0/14`.
		podCIDR?: string

		// IP address block from which to assign service IP addresses, for
		// example `172.30.0.0/16`.
		serviceCIDR?: string
	}

	// The ID of the internal OpenID Connect Provider.
	oidcID!: string

	// ProvisionShardID defines the shard where ROSA hosted control
	// plane components will be hosted.
	provisionShardID?: string

	// The AWS Region the cluster lives in.
	region!: string

	// AWS IAM roles used to perform credential requests by the
	// openshift operators.
	rolesRef!: {
		// ControlPlaneOperatorARN is an ARN value referencing a role
		// appropriate for the Control Plane Operator.
		//
		// The following is an example of a valid policy document:
		//
		// {
		// "Version": "2012-10-17",
		// "Statement": [
		// {
		// "Effect": "Allow",
		// "Action": [
		// "ec2:CreateVpcEndpoint",
		// "ec2:DescribeVpcEndpoints",
		// "ec2:ModifyVpcEndpoint",
		// "ec2:DeleteVpcEndpoints",
		// "ec2:CreateTags",
		// "route53:ListHostedZones",
		// "ec2:CreateSecurityGroup",
		// "ec2:AuthorizeSecurityGroupIngress",
		// "ec2:AuthorizeSecurityGroupEgress",
		// "ec2:DeleteSecurityGroup",
		// "ec2:RevokeSecurityGroupIngress",
		// "ec2:RevokeSecurityGroupEgress",
		// "ec2:DescribeSecurityGroups",
		// "ec2:DescribeVpcs",
		// ],
		// "Resource": "*"
		// },
		// {
		// "Effect": "Allow",
		// "Action": [
		// "route53:ChangeResourceRecordSets",
		// "route53:ListResourceRecordSets"
		// ],
		// "Resource": "arn:aws:route53:::%s"
		// }
		// ]
		// }
		controlPlaneOperatorARN!: string

		// ImageRegistryARN is an ARN value referencing a role appropriate
		// for the Image Registry Operator.
		//
		// The following is an example of a valid policy document:
		//
		// {
		// "Version": "2012-10-17",
		// "Statement": [
		// {
		// "Effect": "Allow",
		// "Action": [
		// "s3:CreateBucket",
		// "s3:DeleteBucket",
		// "s3:PutBucketTagging",
		// "s3:GetBucketTagging",
		// "s3:PutBucketPublicAccessBlock",
		// "s3:GetBucketPublicAccessBlock",
		// "s3:PutEncryptionConfiguration",
		// "s3:GetEncryptionConfiguration",
		// "s3:PutLifecycleConfiguration",
		// "s3:GetLifecycleConfiguration",
		// "s3:GetBucketLocation",
		// "s3:ListBucket",
		// "s3:GetObject",
		// "s3:PutObject",
		// "s3:DeleteObject",
		// "s3:ListBucketMultipartUploads",
		// "s3:AbortMultipartUpload",
		// "s3:ListMultipartUploadParts"
		// ],
		// "Resource": "*"
		// }
		// ]
		// }
		imageRegistryARN!: string

		// The referenced role must have a trust relationship that allows
		// it to be assumed via web identity.
		// https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc.html.
		// Example:
		// {
		// "Version": "2012-10-17",
		// "Statement": [
		// {
		// "Effect": "Allow",
		// "Principal": {
		// "Federated": "{{ .ProviderARN }}"
		// },
		// "Action": "sts:AssumeRoleWithWebIdentity",
		// "Condition": {
		// "StringEquals": {
		// "{{ .ProviderName }}:sub": {{ .ServiceAccounts }}
		// }
		// }
		// }
		// ]
		// }
		//
		// IngressARN is an ARN value referencing a role appropriate for
		// the Ingress Operator.
		//
		// The following is an example of a valid policy document:
		//
		// {
		// "Version": "2012-10-17",
		// "Statement": [
		// {
		// "Effect": "Allow",
		// "Action": [
		// "elasticloadbalancing:DescribeLoadBalancers",
		// "tag:GetResources",
		// "route53:ListHostedZones"
		// ],
		// "Resource": "*"
		// },
		// {
		// "Effect": "Allow",
		// "Action": [
		// "route53:ChangeResourceRecordSets"
		// ],
		// "Resource": [
		// "arn:aws:route53:::PUBLIC_ZONE_ID",
		// "arn:aws:route53:::PRIVATE_ZONE_ID"
		// ]
		// }
		// ]
		// }
		ingressARN!:     string
		kmsProviderARN!: string

		// KubeCloudControllerARN is an ARN value referencing a role
		// appropriate for the KCM/KCC.
		// Source:
		// https://cloud-provider-aws.sigs.k8s.io/prerequisites/#iam-policies
		//
		// The following is an example of a valid policy document:
		//
		// {
		// "Version": "2012-10-17",
		// "Statement": [
		// {
		// "Action": [
		// "autoscaling:DescribeAutoScalingGroups",
		// "autoscaling:DescribeLaunchConfigurations",
		// "autoscaling:DescribeTags",
		// "ec2:DescribeAvailabilityZones",
		// "ec2:DescribeInstances",
		// "ec2:DescribeImages",
		// "ec2:DescribeRegions",
		// "ec2:DescribeRouteTables",
		// "ec2:DescribeSecurityGroups",
		// "ec2:DescribeSubnets",
		// "ec2:DescribeVolumes",
		// "ec2:CreateSecurityGroup",
		// "ec2:CreateTags",
		// "ec2:CreateVolume",
		// "ec2:ModifyInstanceAttribute",
		// "ec2:ModifyVolume",
		// "ec2:AttachVolume",
		// "ec2:AuthorizeSecurityGroupIngress",
		// "ec2:CreateRoute",
		// "ec2:DeleteRoute",
		// "ec2:DeleteSecurityGroup",
		// "ec2:DeleteVolume",
		// "ec2:DetachVolume",
		// "ec2:RevokeSecurityGroupIngress",
		// "ec2:DescribeVpcs",
		// "elasticloadbalancing:AddTags",
		// "elasticloadbalancing:AttachLoadBalancerToSubnets",
		// "elasticloadbalancing:ApplySecurityGroupsToLoadBalancer",
		// "elasticloadbalancing:CreateLoadBalancer",
		// "elasticloadbalancing:CreateLoadBalancerPolicy",
		// "elasticloadbalancing:CreateLoadBalancerListeners",
		// "elasticloadbalancing:ConfigureHealthCheck",
		// "elasticloadbalancing:DeleteLoadBalancer",
		// "elasticloadbalancing:DeleteLoadBalancerListeners",
		// "elasticloadbalancing:DescribeLoadBalancers",
		// "elasticloadbalancing:DescribeLoadBalancerAttributes",
		// "elasticloadbalancing:DetachLoadBalancerFromSubnets",
		// "elasticloadbalancing:DeregisterInstancesFromLoadBalancer",
		// "elasticloadbalancing:ModifyLoadBalancerAttributes",
		// "elasticloadbalancing:RegisterInstancesWithLoadBalancer",
		// "elasticloadbalancing:SetLoadBalancerPoliciesForBackendServer",
		// "elasticloadbalancing:AddTags",
		// "elasticloadbalancing:CreateListener",
		// "elasticloadbalancing:CreateTargetGroup",
		// "elasticloadbalancing:DeleteListener",
		// "elasticloadbalancing:DeleteTargetGroup",
		// "elasticloadbalancing:DeregisterTargets",
		// "elasticloadbalancing:DescribeListeners",
		// "elasticloadbalancing:DescribeLoadBalancerPolicies",
		// "elasticloadbalancing:DescribeTargetGroups",
		// "elasticloadbalancing:DescribeTargetHealth",
		// "elasticloadbalancing:ModifyListener",
		// "elasticloadbalancing:ModifyTargetGroup",
		// "elasticloadbalancing:RegisterTargets",
		// "elasticloadbalancing:SetLoadBalancerPoliciesOfListener",
		// "iam:CreateServiceLinkedRole",
		// "kms:DescribeKey"
		// ],
		// "Resource": [
		// "*"
		// ],
		// "Effect": "Allow"
		// }
		// ]
		// }
		kubeCloudControllerARN!: string

		// NetworkARN is an ARN value referencing a role appropriate for
		// the Network Operator.
		//
		// The following is an example of a valid policy document:
		//
		// {
		// "Version": "2012-10-17",
		// "Statement": [
		// {
		// "Effect": "Allow",
		// "Action": [
		// "ec2:DescribeInstances",
		// "ec2:DescribeInstanceStatus",
		// "ec2:DescribeInstanceTypes",
		// "ec2:UnassignPrivateIpAddresses",
		// "ec2:AssignPrivateIpAddresses",
		// "ec2:UnassignIpv6Addresses",
		// "ec2:AssignIpv6Addresses",
		// "ec2:DescribeSubnets",
		// "ec2:DescribeNetworkInterfaces"
		// ],
		// "Resource": "*"
		// }
		// ]
		// }
		networkARN!: string

		// NodePoolManagementARN is an ARN value referencing a role
		// appropriate for the CAPI Controller.
		//
		// The following is an example of a valid policy document:
		//
		// {
		// "Version": "2012-10-17",
		// "Statement": [
		// {
		// "Action": [
		// "ec2:AssociateRouteTable",
		// "ec2:AttachInternetGateway",
		// "ec2:AuthorizeSecurityGroupIngress",
		// "ec2:CreateInternetGateway",
		// "ec2:CreateNatGateway",
		// "ec2:CreateRoute",
		// "ec2:CreateRouteTable",
		// "ec2:CreateSecurityGroup",
		// "ec2:CreateSubnet",
		// "ec2:CreateTags",
		// "ec2:DeleteInternetGateway",
		// "ec2:DeleteNatGateway",
		// "ec2:DeleteRouteTable",
		// "ec2:DeleteSecurityGroup",
		// "ec2:DeleteSubnet",
		// "ec2:DeleteTags",
		// "ec2:DescribeAccountAttributes",
		// "ec2:DescribeAddresses",
		// "ec2:DescribeAvailabilityZones",
		// "ec2:DescribeImages",
		// "ec2:DescribeInstances",
		// "ec2:DescribeInternetGateways",
		// "ec2:DescribeNatGateways",
		// "ec2:DescribeNetworkInterfaces",
		// "ec2:DescribeNetworkInterfaceAttribute",
		// "ec2:DescribeRouteTables",
		// "ec2:DescribeSecurityGroups",
		// "ec2:DescribeSubnets",
		// "ec2:DescribeVpcs",
		// "ec2:DescribeVpcAttribute",
		// "ec2:DescribeVolumes",
		// "ec2:DetachInternetGateway",
		// "ec2:DisassociateRouteTable",
		// "ec2:DisassociateAddress",
		// "ec2:ModifyInstanceAttribute",
		// "ec2:ModifyNetworkInterfaceAttribute",
		// "ec2:ModifySubnetAttribute",
		// "ec2:RevokeSecurityGroupIngress",
		// "ec2:RunInstances",
		// "ec2:TerminateInstances",
		// "tag:GetResources",
		// "ec2:CreateLaunchTemplate",
		// "ec2:CreateLaunchTemplateVersion",
		// "ec2:DescribeLaunchTemplates",
		// "ec2:DescribeLaunchTemplateVersions",
		// "ec2:DeleteLaunchTemplate",
		// "ec2:DeleteLaunchTemplateVersions"
		// ],
		// "Resource": [
		// "*"
		// ],
		// "Effect": "Allow"
		// },
		// {
		// "Condition": {
		// "StringLike": {
		// "iam:AWSServiceName": "elasticloadbalancing.amazonaws.com"
		// }
		// },
		// "Action": [
		// "iam:CreateServiceLinkedRole"
		// ],
		// "Resource": [
		// "arn:*:iam::*:role/aws-service-role/elasticloadbalancing.amazonaws.com/AWSServiceRoleForElasticLoadBalancing"
		// ],
		// "Effect": "Allow"
		// },
		// {
		// "Action": [
		// "iam:PassRole"
		// ],
		// "Resource": [
		// "arn:*:iam::*:role/*-worker-role"
		// ],
		// "Effect": "Allow"
		// },
		// {
		// "Effect": "Allow",
		// "Action": [
		// "kms:Decrypt",
		// "kms:ReEncrypt",
		// "kms:GenerateDataKeyWithoutPlainText",
		// "kms:DescribeKey"
		// ],
		// "Resource": "*"
		// },
		// {
		// "Effect": "Allow",
		// "Action": [
		// "kms:CreateGrant"
		// ],
		// "Resource": "*",
		// "Condition": {
		// "Bool": {
		// "kms:GrantIsForAWSResource": true
		// }
		// }
		// }
		// ]
		// }
		nodePoolManagementARN!: string

		// StorageARN is an ARN value referencing a role appropriate for
		// the Storage Operator.
		//
		// The following is an example of a valid policy document:
		//
		// {
		// "Version": "2012-10-17",
		// "Statement": [
		// {
		// "Effect": "Allow",
		// "Action": [
		// "ec2:AttachVolume",
		// "ec2:CreateSnapshot",
		// "ec2:CreateTags",
		// "ec2:CreateVolume",
		// "ec2:DeleteSnapshot",
		// "ec2:DeleteTags",
		// "ec2:DeleteVolume",
		// "ec2:DescribeInstances",
		// "ec2:DescribeSnapshots",
		// "ec2:DescribeTags",
		// "ec2:DescribeVolumes",
		// "ec2:DescribeVolumesModifications",
		// "ec2:DetachVolume",
		// "ec2:ModifyVolume"
		// ],
		// "Resource": "*"
		// }
		// ]
		// }
		storageARN!: string
	}

	// Cluster name must be valid DNS-1035 label, so it must consist
	// of lower case alphanumeric
	// characters or '-', start with an alphabetic character, end with
	// an alphanumeric character
	// and have a max length of 54 characters.
	rosaClusterName!: strings.MaxRunes(54) & {
		=~"^[a-z]([-a-z0-9]*[a-z0-9])?$"
	}

	// The Subnet IDs to use when installing the cluster.
	// SubnetIDs should come in pairs; two per availability zone, one
	// private and one public.
	subnets!: [...string]

	// SupportRoleARN is an AWS IAM role used by Red Hat SREs to
	// enable
	// access to the cluster account in order to provide support.
	supportRoleARN!: string

	// OpenShift semantic version, for example "4.14.5".
	version!: string

	// VersionGate requires acknowledgment when upgrading ROSA-HCP
	// y-stream versions (e.g., from 4.15 to 4.16).
	// Default is WaitForAcknowledge.
	// WaitForAcknowledge: If acknowledgment is required, the upgrade
	// will not proceed until VersionGate is set to Acknowledge or
	// AlwaysAcknowledge.
	// Acknowledge: If acknowledgment is required, apply it for the
	// upgrade. After upgrade is done set the version gate to
	// WaitForAcknowledge.
	// AlwaysAcknowledge: If acknowledgment is required, apply it and
	// proceed with the upgrade.
	versionGate!: "Acknowledge" | "WaitForAcknowledge" | "AlwaysAcknowledge"

	// WorkerRoleARN is an AWS IAM role that will be attached to
	// worker instances.
	workerRoleARN!: string
}
