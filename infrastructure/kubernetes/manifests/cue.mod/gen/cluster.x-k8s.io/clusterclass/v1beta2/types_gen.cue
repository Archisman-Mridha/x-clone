// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f /tmp/kue/cluster-api/config/crd/bases/cluster.x-k8s.io_clusterclasses.yaml

package v1beta2

import (
	"strings"
	"list"
	"struct"
)

// ClusterClass is a template which can be used to create managed
// topologies.
// NOTE: This CRD can only be used if the ClusterTopology feature
// gate is enabled.
#ClusterClass: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "cluster.x-k8s.io/v1beta2"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "ClusterClass"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// spec is the desired state of ClusterClass.
	spec!: #ClusterClassSpec
}

// spec is the desired state of ClusterClass.
#ClusterClassSpec: {
	// availabilityGates specifies additional conditions to include
	// when evaluating Cluster Available condition.
	//
	// NOTE: If a Cluster is using this ClusterClass, and this Cluster
	// defines a custom list of availabilityGates,
	// such list overrides availabilityGates defined in this field.
	availabilityGates?: list.MaxItems(32) & [...{
		// conditionType refers to a condition with matching type in the
		// Cluster's condition list.
		// If the conditions doesn't exist, it will be treated as unknown.
		// Note: Both Cluster API conditions or conditions added by 3rd
		// party controllers can be used as availability gates.
		conditionType!: strings.MaxRunes(316) & strings.MinRunes(1) & {
			=~"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
		}

		// polarity of the conditionType specified in this
		// availabilityGate.
		// Valid values are Positive, Negative and omitted.
		// When omitted, the default behaviour will be Positive.
		// A positive polarity means that the condition should report a
		// true status under normal conditions.
		// A negative polarity means that the condition should report a
		// false status under normal conditions.
		polarity?: "Positive" | "Negative"
	}] & [_, ...]

	// controlPlane is a reference to a local struct that holds the
	// details
	// for provisioning the Control Plane for the Cluster.
	controlPlane!: {
		// deletion contains configuration options for Machine deletion.
		deletion?: struct.MinFields(1) & {
			// nodeDeletionTimeoutSeconds defines how long the controller will
			// attempt to delete the Node that the Machine
			// hosts after the Machine is marked for deletion. A duration of 0
			// will retry deletion indefinitely.
			// Defaults to 10 seconds.
			// NOTE: This value can be overridden while defining a
			// Cluster.Topology.
			nodeDeletionTimeoutSeconds?: int32 & >=0

			// nodeDrainTimeoutSeconds is the total amount of time that the
			// controller will spend on draining a node.
			// The default value is 0, meaning that the node can be drained
			// without any time limitations.
			// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain
			// --timeout`
			// NOTE: This value can be overridden while defining a
			// Cluster.Topology.
			nodeDrainTimeoutSeconds?: int32 & >=0

			// nodeVolumeDetachTimeoutSeconds is the total amount of time that
			// the controller will spend on waiting for all volumes
			// to be detached. The default value is 0, meaning that the
			// volumes can be detached without any time limitations.
			// NOTE: This value can be overridden while defining a
			// Cluster.Topology.
			nodeVolumeDetachTimeoutSeconds?: int32 & >=0
		}

		// healthCheck defines a MachineHealthCheck for this
		// ControlPlaneClass.
		// This field is supported if and only if the ControlPlane
		// provider template
		// referenced above is Machine based and supports setting
		// replicas.
		healthCheck?: struct.MinFields(1) & {
			// checks are the checks that are used to evaluate if a Machine is
			// healthy.
			//
			// Independent of this configuration the MachineHealthCheck
			// controller will always
			// flag Machines with `cluster.x-k8s.io/remediate-machine`
			// annotation and
			// Machines with deleted Nodes as unhealthy.
			//
			// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
			// is defaulted to 10 minutes and evaluated accordingly.
			checks?: struct.MinFields(1) & {
				// nodeStartupTimeoutSeconds allows to set the maximum time for
				// MachineHealthCheck
				// to consider a Machine unhealthy if a corresponding Node isn't
				// associated
				// through a `Spec.ProviderID` field.
				//
				// The duration set in this field is compared to the greatest of:
				// - Cluster's infrastructure ready condition timestamp (if and
				// when available)
				// - Control Plane's initialized condition timestamp (if and when
				// available)
				// - Machine's infrastructure ready condition timestamp (if and
				// when available)
				// - Machine's metadata creation timestamp
				//
				// Defaults to 10 minutes.
				// If you wish to disable this feature, set the value explicitly
				// to 0.
				nodeStartupTimeoutSeconds?: int32 & >=0

				// unhealthyNodeConditions contains a list of conditions that
				// determine
				// whether a node is considered unhealthy. The conditions are
				// combined in a
				// logical OR, i.e. if any of the conditions is met, the node is
				// unhealthy.
				unhealthyNodeConditions?: list.MaxItems(100) & [...{
					// status of the condition, one of True, False, Unknown.
					status!: strings.MinRunes(1)

					// timeoutSeconds is the duration that a node must be in a given
					// status for,
					// after which the node is considered unhealthy.
					// For example, with a value of "1h", the node must match the
					// status
					// for at least 1 hour before being considered unhealthy.
					timeoutSeconds!: int32 & >=0

					// type of Node condition
					type!: strings.MinRunes(1)
				}] & [_, ...]
			}

			// remediation configures if and how remediations are triggered if
			// a Machine is unhealthy.
			//
			// If remediation or remediation.triggerIf is not set,
			// remediation will always be triggered for unhealthy Machines.
			//
			// If remediation or remediation.templateRef is not set,
			// the OwnerRemediated condition will be set on unhealthy Machines
			// to trigger remediation via
			// the owner of the Machines, for example a MachineSet or a
			// KubeadmControlPlane.
			remediation?: struct.MinFields(1) & {
				// templateRef is a reference to a remediation template
				// provided by an infrastructure provider.
				//
				// This field is completely optional, when filled, the
				// MachineHealthCheck controller
				// creates a new object from the template referenced and hands off
				// remediation of the machine to
				// a controller that lives outside of Cluster API.
				templateRef?: {
					// apiVersion of the remediation template.
					// apiVersion must be fully qualified domain name followed by /
					// and a version.
					// NOTE: This field must be kept in sync with the APIVersion of
					// the remediation template.
					apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
					}

					// kind of the remediation template.
					// kind must consist of alphanumeric characters or '-', start with
					// an alphabetic character, and end with an alphanumeric
					// character.
					kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
						=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
					}

					// name of the remediation template.
					// name must consist of lower case alphanumeric characters, '-' or
					// '.', and must start and end with an alphanumeric character.
					name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
					}
				}

				// triggerIf configures if remediations are triggered.
				// If this field is not set, remediations are always triggered.
				triggerIf?: struct.MinFields(1) & {
					// unhealthyInRange specifies that remediations are only triggered
					// if the number of
					// unhealthy Machines is in the configured range.
					// Takes precedence over unhealthyLessThanOrEqualTo.
					// Eg. "[3-5]" - This means that remediation will be allowed only
					// when:
					// (a) there are at least 3 unhealthy Machines (and)
					// (b) there are at most 5 unhealthy Machines
					unhealthyInRange?: strings.MaxRunes(32) & strings.MinRunes(1) & {
						=~"^\\[[0-9]+-[0-9]+\\]$"
					}

					// unhealthyLessThanOrEqualTo specifies that remediations are only
					// triggered if the number of
					// unhealthy Machines is less than or equal to the configured
					// value.
					// unhealthyInRange takes precedence if set.
					unhealthyLessThanOrEqualTo?: matchN(>=1, [int, string])
				}
			}
		}
		machineInfrastructure?: {
			// templateRef is a required reference to the template for a
			// MachineInfrastructure of a ControlPlane.
			templateRef!: {
				// apiVersion of the template.
				// apiVersion must be fully qualified domain name followed by /
				// and a version.
				apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
				}

				// kind of the template.
				// kind must consist of alphanumeric characters or '-', start with
				// an alphabetic character, and end with an alphanumeric
				// character.
				kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
				}

				// name of the template.
				// name must consist of lower case alphanumeric characters, '-' or
				// '.', and must start and end with an alphanumeric character.
				name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
				}
			}
		}

		// metadata is the metadata applied to the ControlPlane and the
		// Machines of the ControlPlane
		// if the ControlPlaneTemplate referenced is machine based. If
		// not, it is applied only to the
		// ControlPlane.
		// At runtime this metadata is merged with the corresponding
		// metadata from the topology.
		//
		// This field is supported if and only if the control plane
		// provider template
		// referenced is Machine based.
		metadata?: struct.MinFields(1) & {
			// annotations is an unstructured key value map stored with a
			// resource that may be
			// set by external tools to store and retrieve arbitrary metadata.
			// They are not
			// queryable and should be preserved when modifying objects.
			// More info: http://kubernetes.io/docs/user-guide/annotations
			annotations?: {
				[string]: string
			}

			// labels is a map of string keys and values that can be used to
			// organize and categorize
			// (scope and select) objects. May match selectors of replication
			// controllers
			// and services.
			// More info: http://kubernetes.io/docs/user-guide/labels
			labels?: {
				[string]: string
			}
		}

		// naming allows changing the naming pattern used when creating
		// the control plane provider object.
		naming?: struct.MinFields(1) & {
			// template defines the template to use for generating the name of
			// the ControlPlane object.
			// If not defined, it will fallback to `{{ .cluster.name }}-{{
			// .random }}`.
			// If the templated string exceeds 63 characters, it will be
			// trimmed to 58 characters and will
			// get concatenated with a random suffix of length 5.
			// The templating mechanism provides the following arguments:
			// * `.cluster.name`: The name of the cluster object.
			// * `.random`: A random alphanumeric string, without vowels, of
			// length 5.
			template?: strings.MaxRunes(1024) & strings.MinRunes(1)
		}

		// readinessGates specifies additional conditions to include when
		// evaluating Machine Ready condition.
		//
		// This field can be used e.g. to instruct the machine controller
		// to include in the computation for Machine's ready
		// computation a condition, managed by an external controllers,
		// reporting the status of special software/hardware installed on
		// the Machine.
		//
		// NOTE: If a Cluster defines a custom list of readinessGates for
		// the control plane,
		// such list overrides readinessGates defined in this field.
		// NOTE: Specific control plane provider implementations might
		// automatically extend the list of readinessGates;
		// e.g. the kubeadm control provider adds ReadinessGates for the
		// APIServerPodHealthy, SchedulerPodHealthy conditions, etc.
		readinessGates?: list.MaxItems(32) & [...{
			// conditionType refers to a condition with matching type in the
			// Machine's condition list.
			// If the conditions doesn't exist, it will be treated as unknown.
			// Note: Both Cluster API conditions or conditions added by 3rd
			// party controllers can be used as readiness gates.
			conditionType!: strings.MaxRunes(316) & strings.MinRunes(1) & {
				=~"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
			}

			// polarity of the conditionType specified in this readinessGate.
			// Valid values are Positive, Negative and omitted.
			// When omitted, the default behaviour will be Positive.
			// A positive polarity means that the condition should report a
			// true status under normal conditions.
			// A negative polarity means that the condition should report a
			// false status under normal conditions.
			polarity?: "Positive" | "Negative"
		}] & [_, ...]

		// templateRef contains the reference to a provider-specific
		// control plane template.
		templateRef!: {
			// apiVersion of the template.
			// apiVersion must be fully qualified domain name followed by /
			// and a version.
			apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
			}

			// kind of the template.
			// kind must consist of alphanumeric characters or '-', start with
			// an alphabetic character, and end with an alphanumeric
			// character.
			kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
				=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
			}

			// name of the template.
			// name must consist of lower case alphanumeric characters, '-' or
			// '.', and must start and end with an alphanumeric character.
			name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
			}
		}
	}

	// infrastructure is a reference to a local struct that holds the
	// details
	// for provisioning the infrastructure cluster for the Cluster.
	infrastructure!: {
		// naming allows changing the naming pattern used when creating
		// the infrastructure cluster object.
		naming?: struct.MinFields(1) & {
			// template defines the template to use for generating the name of
			// the Infrastructure object.
			// If not defined, it will fallback to `{{ .cluster.name }}-{{
			// .random }}`.
			// If the templated string exceeds 63 characters, it will be
			// trimmed to 58 characters and will
			// get concatenated with a random suffix of length 5.
			// The templating mechanism provides the following arguments:
			// * `.cluster.name`: The name of the cluster object.
			// * `.random`: A random alphanumeric string, without vowels, of
			// length 5.
			template?: strings.MaxRunes(1024) & strings.MinRunes(1)
		}

		// templateRef contains the reference to a provider-specific
		// infrastructure cluster template.
		templateRef!: {
			// apiVersion of the template.
			// apiVersion must be fully qualified domain name followed by /
			// and a version.
			apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
			}

			// kind of the template.
			// kind must consist of alphanumeric characters or '-', start with
			// an alphabetic character, and end with an alphanumeric
			// character.
			kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
				=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
			}

			// name of the template.
			// name must consist of lower case alphanumeric characters, '-' or
			// '.', and must start and end with an alphanumeric character.
			name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
			}
		}
	}

	// patches defines the patches which are applied to customize
	// referenced templates of a ClusterClass.
	// Note: Patches will be applied in the order of the array.
	patches?: list.MaxItems(1000) & [...{
		// definitions define inline patches.
		// Note: Patches will be applied in the order of the array.
		// Note: Exactly one of Definitions or External must be set.
		definitions?: list.MaxItems(100) & [...{
			// jsonPatches defines the patches which should be applied on the
			// templates
			// matching the selector.
			// Note: Patches will be applied in the order of the array.
			jsonPatches!: list.MaxItems(100) & [...{
				// op defines the operation of the patch.
				// Note: Only `add`, `replace` and `remove` are supported.
				op!: "add" | "replace" | "remove"

				// path defines the path of the patch.
				// Note: Only the spec of a template can be patched, thus the path
				// has to start with /spec/.
				// Note: For now the only allowed array modifications are `append`
				// and `prepend`, i.e.:
				// * for op: `add`: only index 0 (prepend) and - (append) are
				// allowed
				// * for op: `replace` or `remove`: no indexes are allowed
				path!: strings.MaxRunes(512) & strings.MinRunes(1)

				// value defines the value of the patch.
				// Note: Either Value or ValueFrom is required for add and replace
				// operations. Only one of them is allowed to be set at the same
				// time.
				// Note: We have to use apiextensionsv1.JSON instead of our JSON
				// type,
				// because controller-tools has a hard-coded schema for
				// apiextensionsv1.JSON
				// which cannot be produced by another type (unset type field).
				// Ref:
				// https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
				value?: _

				// valueFrom defines the value of the patch.
				// Note: Either Value or ValueFrom is required for add and replace
				// operations. Only one of them is allowed to be set at the same
				// time.
				valueFrom?: {
					// template is the Go template to be used to calculate the value.
					// A template can reference variables defined in .spec.variables
					// and builtin variables.
					// Note: The template must evaluate to a valid YAML or JSON value.
					template?: strings.MaxRunes(10240) & strings.MinRunes(1)

					// variable is the variable to be used as value.
					// Variable can be one of the variables defined in .spec.variables
					// or a builtin variable.
					variable?: strings.MaxRunes(256) & strings.MinRunes(1)
				}
			}] & [_, ...]

			// selector defines on which templates the patch should be
			// applied.
			selector!: {
				// apiVersion filters templates by apiVersion.
				// apiVersion must be fully qualified domain name followed by /
				// and a version.
				apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
				}

				// kind filters templates by kind.
				// kind must consist of alphanumeric characters or '-', start with
				// an alphabetic character, and end with an alphanumeric
				// character.
				kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
				}

				// matchResources selects templates based on where they are
				// referenced.
				matchResources!: struct.MinFields(1) & {
					// controlPlane selects templates referenced in
					// .spec.ControlPlane.
					// Note: this will match the controlPlane and also the
					// controlPlane
					// machineInfrastructure (depending on the kind and apiVersion).
					controlPlane?: bool

					// infrastructureCluster selects templates referenced in
					// .spec.infrastructure.
					infrastructureCluster?: bool
					machineDeploymentClass?: {
						// names selects templates by class names.
						names?: list.MaxItems(100) & [...strings.MaxRunes(256) & strings.MinRunes(1)]
					}
					machinePoolClass?: {
						// names selects templates by class names.
						names?: list.MaxItems(100) & [...strings.MaxRunes(256) & strings.MinRunes(1)]
					}
				}
			}
		}]

		// description is a human-readable description of this patch.
		description?: strings.MaxRunes(1024) & strings.MinRunes(1)

		// enabledIf is a Go template to be used to calculate if a patch
		// should be enabled.
		// It can reference variables defined in .spec.variables and
		// builtin variables.
		// The patch will be enabled if the template evaluates to `true`,
		// otherwise it will
		// be disabled.
		// If EnabledIf is not set, the patch will be enabled per default.
		enabledIf?: strings.MaxRunes(256) & strings.MinRunes(1)

		// external defines an external patch.
		// Note: Exactly one of Definitions or External must be set.
		external?: {
			// discoverVariablesExtension references an extension which is
			// called to discover variables.
			discoverVariablesExtension?: strings.MaxRunes(512) & strings.MinRunes(1)

			// generatePatchesExtension references an extension which is
			// called to generate patches.
			generatePatchesExtension?: strings.MaxRunes(512) & strings.MinRunes(1)

			// settings defines key value pairs to be passed to the
			// extensions.
			// Values defined here take precedence over the values defined in
			// the
			// corresponding ExtensionConfig.
			settings?: {
				[string]: string
			}

			// validateTopologyExtension references an extension which is
			// called to validate the topology.
			validateTopologyExtension?: strings.MaxRunes(512) & strings.MinRunes(1)
		}

		// name of the patch.
		name!: strings.MaxRunes(256) & strings.MinRunes(1)
	}] & [_, ...]

	// variables defines the variables which can be configured
	// in the Cluster topology and are then used in patches.
	variables?: list.MaxItems(1000) & [...{
		// deprecatedV1Beta1Metadata is the metadata of a variable.
		// It can be used to add additional data for higher level tools to
		// a ClusterClassVariable.
		//
		// Deprecated: This field is deprecated and will be removed when
		// support for v1beta1 will be dropped. Please use XMetadata in
		// JSONSchemaProps instead.
		deprecatedV1Beta1Metadata?: struct.MinFields(1) & {
			// annotations is an unstructured key value map that can be used
			// to store and
			// retrieve arbitrary metadata.
			// They are not queryable.
			annotations?: {
				[string]: string
			}

			// labels is a map of string keys and values that can be used to
			// organize and categorize
			// (scope and select) variables.
			labels?: {
				[string]: string
			}
		}

		// name of the variable.
		name!: strings.MaxRunes(256) & strings.MinRunes(1)

		// required specifies if the variable is required.
		// Note: this applies to the variable as a whole and thus the
		// top-level object defined in the schema. If nested fields are
		// required, this will be specified inside the schema.
		required!: bool
		schema!: {
			// openAPIV3Schema defines the schema of a variable via OpenAPI v3
			// schema. The schema is a subset of the schema used in
			// Kubernetes CRDs.
			openAPIV3Schema!: struct.MinFields(1) & {
				// additionalProperties specifies the schema of values in a map
				// (keys are always strings).
				// NOTE: Can only be set if type is object.
				// NOTE: AdditionalProperties is mutually exclusive with
				// Properties.
				// NOTE: This field uses PreserveUnknownFields and Schemaless,
				// because recursive validation is not possible.
				additionalProperties?: _

				// allOf specifies that the variable must validate against all of
				// the subschemas in the array.
				// NOTE: This field uses PreserveUnknownFields and Schemaless,
				// because recursive validation is not possible.
				allOf?: _

				// anyOf specifies that the variable must validate against one or
				// more of the subschemas in the array.
				// NOTE: This field uses PreserveUnknownFields and Schemaless,
				// because recursive validation is not possible.
				anyOf?: _

				// default is the default value of the variable.
				// NOTE: Can be set for all types.
				default?: _

				// description is a human-readable description of this variable.
				description?: strings.MaxRunes(4096) & strings.MinRunes(1)

				// enum is the list of valid values of the variable.
				// NOTE: Can be set for all types.
				enum?: list.MaxItems(100) & [...]

				// example is an example for this variable.
				example?: _

				// exclusiveMaximum specifies if the Maximum is exclusive.
				// NOTE: Can only be set if type is integer or number.
				exclusiveMaximum?: bool

				// exclusiveMinimum specifies if the Minimum is exclusive.
				// NOTE: Can only be set if type is integer or number.
				exclusiveMinimum?: bool

				// format is an OpenAPI v3 format string. Unknown formats are
				// ignored.
				// For a list of supported formats please see: (of the
				// k8s.io/apiextensions-apiserver version we're currently using)
				// https://github.com/kubernetes/apiextensions-apiserver/blob/master/pkg/apiserver/validation/formats.go
				// NOTE: Can only be set if type is string.
				format?: strings.MaxRunes(32) & strings.MinRunes(1)

				// items specifies fields of an array.
				// NOTE: Can only be set if type is array.
				// NOTE: This field uses PreserveUnknownFields and Schemaless,
				// because recursive validation is not possible.
				items?: _

				// maxItems is the max length of an array variable.
				// NOTE: Can only be set if type is array.
				maxItems?: int64

				// maxLength is the max length of a string variable.
				// NOTE: Can only be set if type is string.
				maxLength?: int64

				// maxProperties is the maximum amount of entries in a map or
				// properties in an object.
				// NOTE: Can only be set if type is object.
				maxProperties?: int64

				// maximum is the maximum of an integer or number variable.
				// If ExclusiveMaximum is false, the variable is valid if it is
				// lower than, or equal to, the value of Maximum.
				// If ExclusiveMaximum is true, the variable is valid if it is
				// strictly lower than the value of Maximum.
				// NOTE: Can only be set if type is integer or number.
				maximum?: int64

				// minItems is the min length of an array variable.
				// NOTE: Can only be set if type is array.
				minItems?: int64

				// minLength is the min length of a string variable.
				// NOTE: Can only be set if type is string.
				minLength?: int64

				// minProperties is the minimum amount of entries in a map or
				// properties in an object.
				// NOTE: Can only be set if type is object.
				minProperties?: int64

				// minimum is the minimum of an integer or number variable.
				// If ExclusiveMinimum is false, the variable is valid if it is
				// greater than, or equal to, the value of Minimum.
				// If ExclusiveMinimum is true, the variable is valid if it is
				// strictly greater than the value of Minimum.
				// NOTE: Can only be set if type is integer or number.
				minimum?: int64

				// not specifies that the variable must not validate against the
				// subschema.
				// NOTE: This field uses PreserveUnknownFields and Schemaless,
				// because recursive validation is not possible.
				not?: _

				// oneOf specifies that the variable must validate against exactly
				// one of the subschemas in the array.
				// NOTE: This field uses PreserveUnknownFields and Schemaless,
				// because recursive validation is not possible.
				oneOf?: _

				// pattern is the regex which a string variable must match.
				// NOTE: Can only be set if type is string.
				pattern?: strings.MaxRunes(512) & strings.MinRunes(1)

				// properties specifies fields of an object.
				// NOTE: Can only be set if type is object.
				// NOTE: Properties is mutually exclusive with
				// AdditionalProperties.
				// NOTE: This field uses PreserveUnknownFields and Schemaless,
				// because recursive validation is not possible.
				properties?: _

				// required specifies which fields of an object are required.
				// NOTE: Can only be set if type is object.
				required?: list.MaxItems(1000) & [...strings.MaxRunes(256) & strings.MinRunes(1)] & [_, ...]

				// type is the type of the variable.
				// Valid values are: object, array, string, integer, number or
				// boolean.
				type?: "object" | "array" | "string" | "integer" | "number" | "boolean"

				// uniqueItems specifies if items in an array must be unique.
				// NOTE: Can only be set if type is array.
				uniqueItems?: bool

				// x-kubernetes-int-or-string specifies that this value is
				// either an integer or a string. If this is true, an empty
				// type is allowed and type as child of anyOf is permitted
				// if following one of the following patterns:
				//
				// 1) anyOf:
				// - type: integer
				// - type: string
				// 2) allOf:
				// - anyOf:
				// - type: integer
				// - type: string
				// - ... zero or more
				"x-kubernetes-int-or-string"?: bool

				// x-kubernetes-preserve-unknown-fields allows setting fields in a
				// variable object
				// which are not defined in the variable schema. This affects
				// fields recursively,
				// except if nested properties or additionalProperties are
				// specified in the schema.
				"x-kubernetes-preserve-unknown-fields"?: bool

				// x-kubernetes-validations describes a list of validation rules
				// written in the CEL expression language.
				"x-kubernetes-validations"?: list.MaxItems(100) & [...{
					// fieldPath represents the field path returned when the
					// validation fails.
					// It must be a relative JSON path (i.e. with array notation)
					// scoped to the location of this x-kubernetes-validations
					// extension in the schema and refer to an existing field.
					// e.g. when validation checks if a specific attribute `foo` under
					// a map `testMap`, the fieldPath could be set to `.testMap.foo`
					// If the validation checks two lists must have unique attributes,
					// the fieldPath could be set to either of the list: e.g.
					// `.testList`
					// It does not support list numeric index.
					// It supports child operation to refer to an existing field
					// currently. Refer to [JSONPath support in
					// Kubernetes](https://kubernetes.io/docs/reference/kubectl/jsonpath/)
					// for more info.
					// Numeric index of array is not supported.
					// For field name which contains special characters, use
					// `['specialName']` to refer the field name.
					// e.g. for attribute `foo.34$` appears in a list `testList`, the
					// fieldPath could be set to `.testList['foo.34$']`
					fieldPath?: strings.MaxRunes(512) & strings.MinRunes(1)

					// message represents the message displayed when validation fails.
					// The message is required if the Rule contains
					// line breaks. The message must not contain line breaks.
					// If unset, the message is "failed rule: {Rule}".
					// e.g. "must be a URL with the host matching spec.host"
					message?: strings.MaxRunes(512) & strings.MinRunes(1)

					// messageExpression declares a CEL expression that evaluates to
					// the validation failure message that is returned when this rule
					// fails.
					// Since messageExpression is used as a failure message, it must
					// evaluate to a string.
					// If both message and messageExpression are present on a rule,
					// then messageExpression will be used if validation
					// fails. If messageExpression results in a runtime error, the
					// validation failure message is produced
					// as if the messageExpression field were unset. If
					// messageExpression evaluates to an empty string, a string with
					// only spaces, or a string
					// that contains line breaks, then the validation failure message
					// will also be produced as if the messageExpression field were
					// unset.
					// messageExpression has access to all the same variables as the
					// rule; the only difference is the return type.
					// Example:
					// "x must be less than max ("+string(self.max)+")"
					messageExpression?: strings.MaxRunes(1024) & strings.MinRunes(1)

					// reason provides a machine-readable validation failure reason
					// that is returned to the caller when a request fails this
					// validation rule.
					// The currently supported reasons are: "FieldValueInvalid",
					// "FieldValueForbidden", "FieldValueRequired",
					// "FieldValueDuplicate".
					// If not set, default to use "FieldValueInvalid".
					// All future added reasons must be accepted by clients when
					// reading this value and unknown reasons should be treated as
					// FieldValueInvalid.
					reason?: "FieldValueInvalid" | "FieldValueForbidden" | "FieldValueRequired" | "FieldValueDuplicate"

					// rule represents the expression which will be evaluated by CEL.
					// ref: https://github.com/google/cel-spec
					// The Rule is scoped to the location of the
					// x-kubernetes-validations extension in the schema.
					// The `self` variable in the CEL expression is bound to the
					// scoped value.
					// If the Rule is scoped to an object with properties, the
					// accessible properties of the object are field selectable
					// via `self.field` and field presence can be checked via
					// `has(self.field)`.
					// If the Rule is scoped to an object with additionalProperties
					// (i.e. a map) the value of the map
					// are accessible via `self[mapKey]`, map containment can be
					// checked via `mapKey in self` and all entries of the map
					// are accessible via CEL macros and functions such as
					// `self.all(...)`.
					// If the Rule is scoped to an array, the elements of the array
					// are accessible via `self[i]` and also by macros and
					// functions.
					// If the Rule is scoped to a scalar, `self` is bound to the
					// scalar value.
					// Examples:
					// - Rule scoped to a map of objects: {"rule":
					// "self.components['Widget'].priority < 10"}
					// - Rule scoped to a list of integers: {"rule":
					// "self.values.all(value, value >= 0 && value < 100)"}
					// - Rule scoped to a string value: {"rule":
					// "self.startsWith('kube')"}
					//
					// Unknown data preserved in custom resources via
					// x-kubernetes-preserve-unknown-fields is not accessible in CEL
					// expressions. This includes:
					// - Unknown field values that are preserved by object schemas
					// with x-kubernetes-preserve-unknown-fields.
					// - Object properties where the property schema is of an "unknown
					// type". An "unknown type" is recursively defined as:
					// - A schema with no type and
					// x-kubernetes-preserve-unknown-fields set to true
					// - An array where the items schema is of an "unknown type"
					// - An object where the additionalProperties schema is of an
					// "unknown type"
					//
					// Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*`
					// are accessible.
					// Accessible property names are escaped according to the
					// following rules when accessed in the expression:
					// - '__' escapes to '__underscores__'
					// - '.' escapes to '__dot__'
					// - '-' escapes to '__dash__'
					// - '/' escapes to '__slash__'
					// - Property names that exactly match a CEL RESERVED keyword
					// escape to '__{keyword}__'. The keywords are:
					// "true", "false", "null", "in", "as", "break", "const",
					// "continue", "else", "for", "function", "if",
					// "import", "let", "loop", "package", "namespace", "return".
					// Examples:
					// - Rule accessing a property named "namespace": {"rule":
					// "self.__namespace__ > 0"}
					// - Rule accessing a property named "x-prop": {"rule":
					// "self.x__dash__prop > 0"}
					// - Rule accessing a property named "redact__d": {"rule":
					// "self.redact__underscores__d > 0"}
					//
					// If `rule` makes use of the `oldSelf` variable it is implicitly
					// a
					// `transition rule`.
					//
					// By default, the `oldSelf` variable is the same type as `self`.
					//
					// Transition rules by default are applied only on UPDATE requests
					// and are
					// skipped if an old value could not be found.
					rule!: strings.MaxRunes(4096) & strings.MinRunes(1)
				}] & [_, ...]

				// x-metadata is the metadata of a variable or a nested field
				// within a variable.
				// It can be used to add additional data for higher level tools.
				"x-metadata"?: struct.MinFields(1) & {
					// annotations is an unstructured key value map that can be used
					// to store and
					// retrieve arbitrary metadata.
					// They are not queryable.
					annotations?: {
						[string]: string
					}

					// labels is a map of string keys and values that can be used to
					// organize and categorize
					// (scope and select) variables.
					labels?: {
						[string]: string
					}
				}
			}
		}
	}] & [_, ...]

	// workers describes the worker nodes for the cluster.
	// It is a collection of node types which can be used to create
	// the worker nodes of the cluster.
	workers?: struct.MinFields(1) & {
		// machineDeployments is a list of machine deployment classes that
		// can be used to create
		// a set of worker nodes.
		machineDeployments?: list.MaxItems(100) & [...{
			bootstrap!: {
				// templateRef is a required reference to the BootstrapTemplate
				// for a MachineDeployment.
				templateRef!: {
					// apiVersion of the template.
					// apiVersion must be fully qualified domain name followed by /
					// and a version.
					apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
					}

					// kind of the template.
					// kind must consist of alphanumeric characters or '-', start with
					// an alphabetic character, and end with an alphanumeric
					// character.
					kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
						=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
					}

					// name of the template.
					// name must consist of lower case alphanumeric characters, '-' or
					// '.', and must start and end with an alphanumeric character.
					name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
					}
				}
			}

			// class denotes a type of worker node present in the cluster,
			// this name MUST be unique within a ClusterClass and can be
			// referenced
			// in the Cluster to create a managed MachineDeployment.
			class!: strings.MaxRunes(256) & strings.MinRunes(1)

			// deletion contains configuration options for Machine deletion.
			deletion?: struct.MinFields(1) & {
				// nodeDeletionTimeoutSeconds defines how long the controller will
				// attempt to delete the Node that the Machine
				// hosts after the Machine is marked for deletion. A duration of 0
				// will retry deletion indefinitely.
				// Defaults to 10 seconds.
				// NOTE: This value can be overridden while defining a
				// Cluster.Topology using this MachineDeploymentClass.
				nodeDeletionTimeoutSeconds?: int32 & >=0

				// nodeDrainTimeoutSeconds is the total amount of time that the
				// controller will spend on draining a node.
				// The default value is 0, meaning that the node can be drained
				// without any time limitations.
				// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain
				// --timeout`
				// NOTE: This value can be overridden while defining a
				// Cluster.Topology using this MachineDeploymentClass.
				nodeDrainTimeoutSeconds?: int32 & >=0

				// nodeVolumeDetachTimeoutSeconds is the total amount of time that
				// the controller will spend on waiting for all volumes
				// to be detached. The default value is 0, meaning that the
				// volumes can be detached without any time limitations.
				// NOTE: This value can be overridden while defining a
				// Cluster.Topology using this MachineDeploymentClass.
				nodeVolumeDetachTimeoutSeconds?: int32 & >=0

				// order defines the order in which Machines are deleted when
				// downscaling.
				// Defaults to "Random". Valid values are "Random, "Newest",
				// "Oldest"
				order?: "Random" | "Newest" | "Oldest"
			}

			// failureDomain is the failure domain the machines will be
			// created in.
			// Must match the name of a FailureDomain from the Cluster status.
			// NOTE: This value can be overridden while defining a
			// Cluster.Topology using this MachineDeploymentClass.
			failureDomain?: strings.MaxRunes(256) & strings.MinRunes(1)

			// healthCheck defines a MachineHealthCheck for this
			// MachineDeploymentClass.
			healthCheck?: struct.MinFields(1) & {
				// checks are the checks that are used to evaluate if a Machine is
				// healthy.
				//
				// Independent of this configuration the MachineHealthCheck
				// controller will always
				// flag Machines with `cluster.x-k8s.io/remediate-machine`
				// annotation and
				// Machines with deleted Nodes as unhealthy.
				//
				// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
				// is defaulted to 10 minutes and evaluated accordingly.
				checks?: struct.MinFields(1) & {
					// nodeStartupTimeoutSeconds allows to set the maximum time for
					// MachineHealthCheck
					// to consider a Machine unhealthy if a corresponding Node isn't
					// associated
					// through a `Spec.ProviderID` field.
					//
					// The duration set in this field is compared to the greatest of:
					// - Cluster's infrastructure ready condition timestamp (if and
					// when available)
					// - Control Plane's initialized condition timestamp (if and when
					// available)
					// - Machine's infrastructure ready condition timestamp (if and
					// when available)
					// - Machine's metadata creation timestamp
					//
					// Defaults to 10 minutes.
					// If you wish to disable this feature, set the value explicitly
					// to 0.
					nodeStartupTimeoutSeconds?: int32 & >=0

					// unhealthyNodeConditions contains a list of conditions that
					// determine
					// whether a node is considered unhealthy. The conditions are
					// combined in a
					// logical OR, i.e. if any of the conditions is met, the node is
					// unhealthy.
					unhealthyNodeConditions?: list.MaxItems(100) & [...{
						// status of the condition, one of True, False, Unknown.
						status!: strings.MinRunes(1)

						// timeoutSeconds is the duration that a node must be in a given
						// status for,
						// after which the node is considered unhealthy.
						// For example, with a value of "1h", the node must match the
						// status
						// for at least 1 hour before being considered unhealthy.
						timeoutSeconds!: int32 & >=0

						// type of Node condition
						type!: strings.MinRunes(1)
					}] & [_, ...]
				}

				// remediation configures if and how remediations are triggered if
				// a Machine is unhealthy.
				//
				// If remediation or remediation.triggerIf is not set,
				// remediation will always be triggered for unhealthy Machines.
				//
				// If remediation or remediation.templateRef is not set,
				// the OwnerRemediated condition will be set on unhealthy Machines
				// to trigger remediation via
				// the owner of the Machines, for example a MachineSet or a
				// KubeadmControlPlane.
				remediation?: struct.MinFields(1) & {
					// maxInFlight determines how many in flight remediations should
					// happen at the same time.
					//
					// Remediation only happens on the MachineSet with the most
					// current revision, while
					// older MachineSets (usually present during rollout operations)
					// aren't allowed to remediate.
					//
					// Note: In general (independent of remediations), unhealthy
					// machines are always
					// prioritized during scale down operations over healthy ones.
					//
					// MaxInFlight can be set to a fixed number or a percentage.
					// Example: when this is set to 20%, the MachineSet controller
					// deletes at most 20% of
					// the desired replicas.
					//
					// If not set, remediation is limited to all machines (bounded by
					// replicas)
					// under the active MachineSet's management.
					maxInFlight?: matchN(>=1, [int, string])

					// templateRef is a reference to a remediation template
					// provided by an infrastructure provider.
					//
					// This field is completely optional, when filled, the
					// MachineHealthCheck controller
					// creates a new object from the template referenced and hands off
					// remediation of the machine to
					// a controller that lives outside of Cluster API.
					templateRef?: {
						// apiVersion of the remediation template.
						// apiVersion must be fully qualified domain name followed by /
						// and a version.
						// NOTE: This field must be kept in sync with the APIVersion of
						// the remediation template.
						apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
							=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
						}

						// kind of the remediation template.
						// kind must consist of alphanumeric characters or '-', start with
						// an alphabetic character, and end with an alphanumeric
						// character.
						kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
							=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
						}

						// name of the remediation template.
						// name must consist of lower case alphanumeric characters, '-' or
						// '.', and must start and end with an alphanumeric character.
						name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
							=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
						}
					}

					// triggerIf configures if remediations are triggered.
					// If this field is not set, remediations are always triggered.
					triggerIf?: struct.MinFields(1) & {
						// unhealthyInRange specifies that remediations are only triggered
						// if the number of
						// unhealthy Machines is in the configured range.
						// Takes precedence over unhealthyLessThanOrEqualTo.
						// Eg. "[3-5]" - This means that remediation will be allowed only
						// when:
						// (a) there are at least 3 unhealthy Machines (and)
						// (b) there are at most 5 unhealthy Machines
						unhealthyInRange?: strings.MaxRunes(32) & strings.MinRunes(1) & {
							=~"^\\[[0-9]+-[0-9]+\\]$"
						}

						// unhealthyLessThanOrEqualTo specifies that remediations are only
						// triggered if the number of
						// unhealthy Machines is less than or equal to the configured
						// value.
						// unhealthyInRange takes precedence if set.
						unhealthyLessThanOrEqualTo?: matchN(>=1, [int, string])
					}
				}
			}
			infrastructure!: {
				// templateRef is a required reference to the
				// InfrastructureTemplate for a MachineDeployment.
				templateRef!: {
					// apiVersion of the template.
					// apiVersion must be fully qualified domain name followed by /
					// and a version.
					apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
					}

					// kind of the template.
					// kind must consist of alphanumeric characters or '-', start with
					// an alphabetic character, and end with an alphanumeric
					// character.
					kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
						=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
					}

					// name of the template.
					// name must consist of lower case alphanumeric characters, '-' or
					// '.', and must start and end with an alphanumeric character.
					name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
					}
				}
			}

			// metadata is the metadata applied to the MachineDeployment and
			// the machines of the MachineDeployment.
			// At runtime this metadata is merged with the corresponding
			// metadata from the topology.
			metadata?: struct.MinFields(1) & {
				// annotations is an unstructured key value map stored with a
				// resource that may be
				// set by external tools to store and retrieve arbitrary metadata.
				// They are not
				// queryable and should be preserved when modifying objects.
				// More info: http://kubernetes.io/docs/user-guide/annotations
				annotations?: {
					[string]: string
				}

				// labels is a map of string keys and values that can be used to
				// organize and categorize
				// (scope and select) objects. May match selectors of replication
				// controllers
				// and services.
				// More info: http://kubernetes.io/docs/user-guide/labels
				labels?: {
					[string]: string
				}
			}

			// minReadySeconds is the minimum number of seconds for which a
			// newly created machine should
			// be ready.
			// Defaults to 0 (machine will be considered available as soon as
			// it
			// is ready)
			// NOTE: This value can be overridden while defining a
			// Cluster.Topology using this MachineDeploymentClass.
			minReadySeconds?: int32 & >=0

			// naming allows changing the naming pattern used when creating
			// the MachineDeployment.
			naming?: struct.MinFields(1) & {
				// template defines the template to use for generating the name of
				// the MachineDeployment object.
				// If not defined, it will fallback to `{{ .cluster.name }}-{{
				// .machineDeployment.topologyName }}-{{ .random }}`.
				// If the templated string exceeds 63 characters, it will be
				// trimmed to 58 characters and will
				// get concatenated with a random suffix of length 5.
				// The templating mechanism provides the following arguments:
				// * `.cluster.name`: The name of the cluster object.
				// * `.random`: A random alphanumeric string, without vowels, of
				// length 5.
				// * `.machineDeployment.topologyName`: The name of the
				// MachineDeployment topology
				// (Cluster.spec.topology.workers.machineDeployments[].name).
				template?: strings.MaxRunes(1024) & strings.MinRunes(1)
			}

			// readinessGates specifies additional conditions to include when
			// evaluating Machine Ready condition.
			//
			// This field can be used e.g. to instruct the machine controller
			// to include in the computation for Machine's ready
			// computation a condition, managed by an external controllers,
			// reporting the status of special software/hardware installed on
			// the Machine.
			//
			// NOTE: If a Cluster defines a custom list of readinessGates for
			// a MachineDeployment using this MachineDeploymentClass,
			// such list overrides readinessGates defined in this field.
			readinessGates?: list.MaxItems(32) & [...{
				// conditionType refers to a condition with matching type in the
				// Machine's condition list.
				// If the conditions doesn't exist, it will be treated as unknown.
				// Note: Both Cluster API conditions or conditions added by 3rd
				// party controllers can be used as readiness gates.
				conditionType!: strings.MaxRunes(316) & strings.MinRunes(1) & {
					=~"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
				}

				// polarity of the conditionType specified in this readinessGate.
				// Valid values are Positive, Negative and omitted.
				// When omitted, the default behaviour will be Positive.
				// A positive polarity means that the condition should report a
				// true status under normal conditions.
				// A negative polarity means that the condition should report a
				// false status under normal conditions.
				polarity?: "Positive" | "Negative"
			}] & [_, ...]

			// rollout allows you to configure the behaviour of rolling
			// updates to the MachineDeployment Machines.
			// It allows you to define the strategy used during rolling
			// replacements.
			rollout?: struct.MinFields(1) & {
				// strategy specifies how to roll out control plane Machines.
				strategy?: struct.MinFields(1) & {
					// rollingUpdate is the rolling update config params. Present only
					// if
					// type = RollingUpdate.
					rollingUpdate?: struct.MinFields(1) & {
						// maxSurge is the maximum number of machines that can be
						// scheduled above the
						// desired number of machines.
						// Value can be an absolute number (ex: 5) or a percentage of
						// desired machines (ex: 10%).
						// This can not be 0 if MaxUnavailable is 0.
						// Absolute number is calculated from percentage by rounding up.
						// Defaults to 1.
						// Example: when this is set to 30%, the new MachineSet can be
						// scaled
						// up immediately when the rolling update starts, such that the
						// total
						// number of old and new machines do not exceed 130% of desired
						// machines. Once old machines have been killed, new MachineSet
						// can
						// be scaled up further, ensuring that total number of machines
						// running
						// at any time during the update is at most 130% of desired
						// machines.
						maxSurge?: matchN(>=1, [int, string])

						// maxUnavailable is the maximum number of machines that can be
						// unavailable during the update.
						// Value can be an absolute number (ex: 5) or a percentage of
						// desired
						// machines (ex: 10%).
						// Absolute number is calculated from percentage by rounding down.
						// This can not be 0 if MaxSurge is 0.
						// Defaults to 0.
						// Example: when this is set to 30%, the old MachineSet can be
						// scaled
						// down to 70% of desired machines immediately when the rolling
						// update
						// starts. Once new machines are ready, old MachineSet can be
						// scaled
						// down further, followed by scaling up the new MachineSet,
						// ensuring
						// that the total number of machines available at all times
						// during the update is at least 70% of desired machines.
						maxUnavailable?: matchN(>=1, [int, string])
					}

					// type of rollout. Allowed values are RollingUpdate and OnDelete.
					// Default is RollingUpdate.
					type!: "RollingUpdate" | "OnDelete"
				}
			}
		}] & [_, ...]

		// machinePools is a list of machine pool classes that can be used
		// to create
		// a set of worker nodes.
		machinePools?: list.MaxItems(100) & [...{
			bootstrap!: {
				// templateRef is a required reference to the BootstrapTemplate
				// for a MachinePool.
				templateRef!: {
					// apiVersion of the template.
					// apiVersion must be fully qualified domain name followed by /
					// and a version.
					apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
					}

					// kind of the template.
					// kind must consist of alphanumeric characters or '-', start with
					// an alphabetic character, and end with an alphanumeric
					// character.
					kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
						=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
					}

					// name of the template.
					// name must consist of lower case alphanumeric characters, '-' or
					// '.', and must start and end with an alphanumeric character.
					name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
					}
				}
			}

			// class denotes a type of machine pool present in the cluster,
			// this name MUST be unique within a ClusterClass and can be
			// referenced
			// in the Cluster to create a managed MachinePool.
			class!: strings.MaxRunes(256) & strings.MinRunes(1)

			// deletion contains configuration options for Machine deletion.
			deletion?: struct.MinFields(1) & {
				// nodeDeletionTimeoutSeconds defines how long the controller will
				// attempt to delete the Node that the Machine
				// hosts after the Machine Pool is marked for deletion. A duration
				// of 0 will retry deletion indefinitely.
				// Defaults to 10 seconds.
				// NOTE: This value can be overridden while defining a
				// Cluster.Topology using this MachinePoolClass.
				nodeDeletionTimeoutSeconds?: int32 & >=0

				// nodeDrainTimeoutSeconds is the total amount of time that the
				// controller will spend on draining a node.
				// The default value is 0, meaning that the node can be drained
				// without any time limitations.
				// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain
				// --timeout`
				// NOTE: This value can be overridden while defining a
				// Cluster.Topology using this MachinePoolClass.
				nodeDrainTimeoutSeconds?: int32 & >=0

				// nodeVolumeDetachTimeoutSeconds is the total amount of time that
				// the controller will spend on waiting for all volumes
				// to be detached. The default value is 0, meaning that the
				// volumes can be detached without any time limitations.
				// NOTE: This value can be overridden while defining a
				// Cluster.Topology using this MachinePoolClass.
				nodeVolumeDetachTimeoutSeconds?: int32 & >=0
			}

			// failureDomains is the list of failure domains the MachinePool
			// should be attached to.
			// Must match a key in the FailureDomains map stored on the
			// cluster object.
			// NOTE: This value can be overridden while defining a
			// Cluster.Topology using this MachinePoolClass.
			failureDomains?: list.MaxItems(100) & [...strings.MaxRunes(256) & strings.MinRunes(1)]
			infrastructure!: {
				// templateRef is a required reference to the
				// InfrastructureTemplate for a MachinePool.
				templateRef!: {
					// apiVersion of the template.
					// apiVersion must be fully qualified domain name followed by /
					// and a version.
					apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
					}

					// kind of the template.
					// kind must consist of alphanumeric characters or '-', start with
					// an alphabetic character, and end with an alphanumeric
					// character.
					kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
						=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
					}

					// name of the template.
					// name must consist of lower case alphanumeric characters, '-' or
					// '.', and must start and end with an alphanumeric character.
					name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
					}
				}
			}

			// metadata is the metadata applied to the MachinePool.
			// At runtime this metadata is merged with the corresponding
			// metadata from the topology.
			metadata?: struct.MinFields(1) & {
				// annotations is an unstructured key value map stored with a
				// resource that may be
				// set by external tools to store and retrieve arbitrary metadata.
				// They are not
				// queryable and should be preserved when modifying objects.
				// More info: http://kubernetes.io/docs/user-guide/annotations
				annotations?: {
					[string]: string
				}

				// labels is a map of string keys and values that can be used to
				// organize and categorize
				// (scope and select) objects. May match selectors of replication
				// controllers
				// and services.
				// More info: http://kubernetes.io/docs/user-guide/labels
				labels?: {
					[string]: string
				}
			}

			// minReadySeconds is the minimum number of seconds for which a
			// newly created machine pool should
			// be ready.
			// Defaults to 0 (machine will be considered available as soon as
			// it
			// is ready)
			// NOTE: This value can be overridden while defining a
			// Cluster.Topology using this MachinePoolClass.
			minReadySeconds?: int32 & >=0

			// naming allows changing the naming pattern used when creating
			// the MachinePool.
			naming?: struct.MinFields(1) & {
				// template defines the template to use for generating the name of
				// the MachinePool object.
				// If not defined, it will fallback to `{{ .cluster.name }}-{{
				// .machinePool.topologyName }}-{{ .random }}`.
				// If the templated string exceeds 63 characters, it will be
				// trimmed to 58 characters and will
				// get concatenated with a random suffix of length 5.
				// The templating mechanism provides the following arguments:
				// * `.cluster.name`: The name of the cluster object.
				// * `.random`: A random alphanumeric string, without vowels, of
				// length 5.
				// * `.machinePool.topologyName`: The name of the MachinePool
				// topology (Cluster.spec.topology.workers.machinePools[].name).
				template?: strings.MaxRunes(1024) & strings.MinRunes(1)
			}
		}] & [_, ...]
	}
}
