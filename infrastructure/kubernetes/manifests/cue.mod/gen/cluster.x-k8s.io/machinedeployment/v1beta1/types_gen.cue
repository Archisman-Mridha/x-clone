// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f /tmp/kue/cluster-api/config/crd/bases/cluster.x-k8s.io_machinedeployments.yaml

package v1beta1

import (
	"strings"
	"time"
	"list"
)

// MachineDeployment is the Schema for the machinedeployments API.
#MachineDeployment: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "cluster.x-k8s.io/v1beta1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "MachineDeployment"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// spec is the desired state of MachineDeployment.
	spec!: #MachineDeploymentSpec
}

// spec is the desired state of MachineDeployment.
#MachineDeploymentSpec: {
	// clusterName is the name of the Cluster this object belongs to.
	clusterName!: strings.MaxRunes(63) & strings.MinRunes(1)
	machineNamingStrategy?: {
		// template defines the template to use for generating the names
		// of the
		// Machine objects.
		// If not defined, it will fallback to `{{ .machineSet.name }}-{{
		// .random }}`.
		// If the generated name string exceeds 63 characters, it will be
		// trimmed to
		// 58 characters and will
		// get concatenated with a random suffix of length 5.
		// Length of the template string must not exceed 256 characters.
		// The template allows the following variables `.cluster.name`,
		// `.machineSet.name` and `.random`.
		// The variable `.cluster.name` retrieves the name of the cluster
		// object
		// that owns the Machines being created.
		// The variable `.machineSet.name` retrieves the name of the
		// MachineSet
		// object that owns the Machines being created.
		// The variable `.random` is substituted with random alphanumeric
		// string,
		// without vowels, of length 5. This variable is required part of
		// the
		// template. If not provided, validation will fail.
		template?: strings.MaxRunes(256) & strings.MinRunes(1)
	}

	// minReadySeconds is the minimum number of seconds for which a
	// Node for a newly created machine should be ready before
	// considering the replica available.
	// Defaults to 0 (machine will be considered available as soon as
	// the Node is ready)
	minReadySeconds?: int32

	// paused indicates that the deployment is paused.
	paused?: bool

	// progressDeadlineSeconds is the maximum time in seconds for a
	// deployment to make progress before it
	// is considered to be failed. The deployment controller will
	// continue to
	// process failed deployments and a condition with a
	// ProgressDeadlineExceeded
	// reason will be surfaced in the deployment status. Note that
	// progress will
	// not be estimated during the time a deployment is paused.
	// Defaults to 600s.
	//
	// Deprecated: This field is deprecated and is going to be removed
	// in the next apiVersion. Please see
	// https://github.com/kubernetes-sigs/cluster-api/issues/11470
	// for more details.
	progressDeadlineSeconds?: int32

	// replicas is the number of desired machines.
	// This is a pointer to distinguish between explicit zero and not
	// specified.
	//
	// Defaults to:
	// * if the Kubernetes autoscaler min size and max size
	// annotations are set:
	// - if it's a new MachineDeployment, use min size
	// - if the replicas field of the old MachineDeployment is < min
	// size, use min size
	// - if the replicas field of the old MachineDeployment is > max
	// size, use max size
	// - if the replicas field of the old MachineDeployment is in the
	// (min size, max size) range, keep the value from the oldMD
	// * otherwise use 1
	// Note: Defaulting will be run whenever the replicas field is not
	// set:
	// * A new MachineDeployment is created with replicas not set.
	// * On an existing MachineDeployment the replicas field was first
	// set and is now unset.
	// Those cases are especially relevant for the following
	// Kubernetes autoscaler use cases:
	// * A new MachineDeployment is created and replicas should be
	// managed by the autoscaler
	// * An existing MachineDeployment which initially wasn't
	// controlled by the autoscaler
	// should be later controlled by the autoscaler
	replicas?: int32

	// revisionHistoryLimit is the number of old MachineSets to retain
	// to allow rollback.
	// This is a pointer to distinguish between explicit zero and not
	// specified.
	// Defaults to 1.
	//
	// Deprecated: This field is deprecated and is going to be removed
	// in the next apiVersion. Please see
	// https://github.com/kubernetes-sigs/cluster-api/issues/10479
	// for more details.
	revisionHistoryLimit?: int32

	// rolloutAfter is a field to indicate a rollout should be
	// performed
	// after the specified time even if no changes have been made to
	// the
	// MachineDeployment.
	// Example: In the YAML the time can be specified in the RFC3339
	// format.
	// To specify the rolloutAfter target as March 9, 2023, at 9 am
	// UTC
	// use "2023-03-09T09:00:00Z".
	rolloutAfter?: time.Time

	// selector is the label selector for machines. Existing
	// MachineSets whose machines are
	// selected by this will be the ones affected by this deployment.
	// It must match the machine template's labels.
	selector!: {
		// matchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key!: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator!: string

			// values is an array of string values. If the operator is In or
			// NotIn,
			// the values array must be non-empty. If the operator is Exists
			// or DoesNotExist,
			// the values array must be empty. This array is replaced during a
			// strategic
			// merge patch.
			values?: [...string]
		}]

		// matchLabels is a map of {key,value} pairs. A single {key,value}
		// in the matchLabels
		// map is equivalent to an element of matchExpressions, whose key
		// field is "key", the
		// operator is "In", and the values array contains only "value".
		// The requirements are ANDed.
		matchLabels?: {
			[string]: string
		}
	}

	// strategy is the deployment strategy to use to replace existing
	// machines with
	// new ones.
	strategy?: {
		remediation?: {
			// maxInFlight determines how many in flight remediations should
			// happen at the same time.
			//
			// Remediation only happens on the MachineSet with the most
			// current revision, while
			// older MachineSets (usually present during rollout operations)
			// aren't allowed to remediate.
			//
			// Note: In general (independent of remediations), unhealthy
			// machines are always
			// prioritized during scale down operations over healthy ones.
			//
			// MaxInFlight can be set to a fixed number or a percentage.
			// Example: when this is set to 20%, the MachineSet controller
			// deletes at most 20% of
			// the desired replicas.
			//
			// If not set, remediation is limited to all machines (bounded by
			// replicas)
			// under the active MachineSet's management.
			maxInFlight?: matchN(>=1, [int, string])
		}

		// rollingUpdate is the rolling update config params. Present only
		// if
		// MachineDeploymentStrategyType = RollingUpdate.
		rollingUpdate?: {
			// deletePolicy defines the policy used by the MachineDeployment
			// to identify nodes to delete when downscaling.
			// Valid values are "Random, "Newest", "Oldest"
			// When no value is supplied, the default DeletePolicy of
			// MachineSet is used
			deletePolicy?: "Random" | "Newest" | "Oldest"

			// maxSurge is the maximum number of machines that can be
			// scheduled above the
			// desired number of machines.
			// Value can be an absolute number (ex: 5) or a percentage of
			// desired machines (ex: 10%).
			// This can not be 0 if MaxUnavailable is 0.
			// Absolute number is calculated from percentage by rounding up.
			// Defaults to 1.
			// Example: when this is set to 30%, the new MachineSet can be
			// scaled
			// up immediately when the rolling update starts, such that the
			// total
			// number of old and new machines do not exceed 130% of desired
			// machines. Once old machines have been killed, new MachineSet
			// can
			// be scaled up further, ensuring that total number of machines
			// running
			// at any time during the update is at most 130% of desired
			// machines.
			maxSurge?: matchN(>=1, [int, string])

			// maxUnavailable is the maximum number of machines that can be
			// unavailable during the update.
			// Value can be an absolute number (ex: 5) or a percentage of
			// desired
			// machines (ex: 10%).
			// Absolute number is calculated from percentage by rounding down.
			// This can not be 0 if MaxSurge is 0.
			// Defaults to 0.
			// Example: when this is set to 30%, the old MachineSet can be
			// scaled
			// down to 70% of desired machines immediately when the rolling
			// update
			// starts. Once new machines are ready, old MachineSet can be
			// scaled
			// down further, followed by scaling up the new MachineSet,
			// ensuring
			// that the total number of machines available at all times
			// during the update is at least 70% of desired machines.
			maxUnavailable?: matchN(>=1, [int, string])
		}

		// type of deployment. Allowed values are RollingUpdate and
		// OnDelete.
		// The default is RollingUpdate.
		type?: "RollingUpdate" | "OnDelete"
	}

	// template describes the machines that will be created.
	template!: {
		// metadata is the standard object's metadata.
		// More info:
		// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
		metadata?: {
			// annotations is an unstructured key value map stored with a
			// resource that may be
			// set by external tools to store and retrieve arbitrary metadata.
			// They are not
			// queryable and should be preserved when modifying objects.
			// More info: http://kubernetes.io/docs/user-guide/annotations
			annotations?: {
				[string]: string
			}

			// labels is a map of string keys and values that can be used to
			// organize and categorize
			// (scope and select) objects. May match selectors of replication
			// controllers
			// and services.
			// More info: http://kubernetes.io/docs/user-guide/labels
			labels?: {
				[string]: string
			}
		}

		// spec is the specification of the desired behavior of the
		// machine.
		// More info:
		// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
		spec?: {
			// bootstrap is a reference to a local struct which encapsulates
			// fields to configure the Machineâ€™s bootstrapping mechanism.
			bootstrap!: {
				// configRef is a reference to a bootstrap provider-specific
				// resource
				// that holds configuration details. The reference is optional to
				// allow users/operators to specify Bootstrap.DataSecretName
				// without
				// the need of a controller.
				configRef?: {
					// API version of the referent.
					apiVersion?: string

					// If referring to a piece of an object instead of an entire
					// object, this string
					// should contain a valid JSON/Go field access statement, such as
					// desiredState.manifest.containers[2].
					// For example, if the object reference is to a container within a
					// pod, this would take on a value like:
					// "spec.containers{name}" (where "name" refers to the name of the
					// container that triggered
					// the event) or if no container name is specified
					// "spec.containers[2]" (container with
					// index 2 in this pod). This syntax is chosen only to have some
					// well-defined way of
					// referencing a part of an object.
					fieldPath?: string

					// Kind of the referent.
					// More info:
					// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
					kind?: string

					// Name of the referent.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Namespace of the referent.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
					namespace?: string

					// Specific resourceVersion to which this reference is made, if
					// any.
					// More info:
					// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
					resourceVersion?: string

					// UID of the referent.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
					uid?: string
				}

				// dataSecretName is the name of the secret that stores the
				// bootstrap data script.
				// If nil, the Machine should remain in the Pending state.
				dataSecretName?: strings.MaxRunes(253) & strings.MinRunes(0)
			}

			// clusterName is the name of the Cluster this object belongs to.
			clusterName!: strings.MaxRunes(63) & strings.MinRunes(1)

			// failureDomain is the failure domain the machine will be created
			// in.
			// Must match a key in the FailureDomains map stored on the
			// cluster object.
			failureDomain?: strings.MaxRunes(256) & strings.MinRunes(1)

			// infrastructureRef is a required reference to a custom resource
			// offered by an infrastructure provider.
			infrastructureRef!: {
				// API version of the referent.
				apiVersion?: string

				// If referring to a piece of an object instead of an entire
				// object, this string
				// should contain a valid JSON/Go field access statement, such as
				// desiredState.manifest.containers[2].
				// For example, if the object reference is to a container within a
				// pod, this would take on a value like:
				// "spec.containers{name}" (where "name" refers to the name of the
				// container that triggered
				// the event) or if no container name is specified
				// "spec.containers[2]" (container with
				// index 2 in this pod). This syntax is chosen only to have some
				// well-defined way of
				// referencing a part of an object.
				fieldPath?: string

				// Kind of the referent.
				// More info:
				// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
				kind?: string

				// Name of the referent.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Namespace of the referent.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
				namespace?: string

				// Specific resourceVersion to which this reference is made, if
				// any.
				// More info:
				// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
				resourceVersion?: string

				// UID of the referent.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
				uid?: string
			}

			// nodeDeletionTimeout defines how long the controller will
			// attempt to delete the Node that the Machine
			// hosts after the Machine is marked for deletion. A duration of 0
			// will retry deletion indefinitely.
			// Defaults to 10 seconds.
			nodeDeletionTimeout?: string

			// nodeDrainTimeout is the total amount of time that the
			// controller will spend on draining a node.
			// The default value is 0, meaning that the node can be drained
			// without any time limitations.
			// NOTE: NodeDrainTimeout is different from `kubectl drain
			// --timeout`
			nodeDrainTimeout?: string

			// nodeVolumeDetachTimeout is the total amount of time that the
			// controller will spend on waiting for all volumes
			// to be detached. The default value is 0, meaning that the
			// volumes can be detached without any time limitations.
			nodeVolumeDetachTimeout?: string

			// providerID is the identification ID of the machine provided by
			// the provider.
			// This field must match the provider ID as seen on the node
			// object corresponding to this machine.
			// This field is required by higher level consumers of
			// cluster-api. Example use case is cluster autoscaler
			// with cluster-api as provider. Clean-up logic in the autoscaler
			// compares machines to nodes to find out
			// machines at provider which could not get registered as
			// Kubernetes nodes. With cluster-api as a
			// generic out-of-tree provider for autoscaler, this field is
			// required by autoscaler to be
			// able to have a provider view of the list of machines. Another
			// list of nodes is queried from the k8s apiserver
			// and then a comparison is done to find out unregistered machines
			// and are marked for delete.
			// This field will be set by the actuators and consumed by higher
			// level entities like autoscaler that will
			// be interfacing with cluster-api as generic provider.
			providerID?: strings.MaxRunes(512) & strings.MinRunes(1)

			// readinessGates specifies additional conditions to include when
			// evaluating Machine Ready condition.
			//
			// This field can be used e.g. by Cluster API control plane
			// providers to extend the semantic of the
			// Ready condition for the Machine they control, like the kubeadm
			// control provider adding ReadinessGates
			// for the APIServerPodHealthy, SchedulerPodHealthy conditions,
			// etc.
			//
			// Another example are external controllers, e.g. responsible to
			// install special software/hardware on the Machines;
			// they can include the status of those components with a new
			// condition and add this condition to ReadinessGates.
			//
			// NOTE: This field is considered only for computing v1beta2
			// conditions.
			// NOTE: In case readinessGates conditions start with the
			// APIServer, ControllerManager, Scheduler prefix, and all those
			// readiness gates condition are reporting the same message, when
			// computing the Machine's Ready condition those
			// readinessGates will be replaced by a single entry reporting
			// "Control plane components: " + message.
			// This helps to improve readability of conditions bubbling up to
			// the Machine's owner resource / to the Cluster).
			readinessGates?: list.MaxItems(32) & [...{
				// conditionType refers to a condition with matching type in the
				// Machine's condition list.
				// If the conditions doesn't exist, it will be treated as unknown.
				// Note: Both Cluster API conditions or conditions added by 3rd
				// party controllers can be used as readiness gates.
				conditionType!: strings.MaxRunes(316) & strings.MinRunes(1) & {
					=~"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
				}

				// polarity of the conditionType specified in this readinessGate.
				// Valid values are Positive, Negative and omitted.
				// When omitted, the default behaviour will be Positive.
				// A positive polarity means that the condition should report a
				// true status under normal conditions.
				// A negative polarity means that the condition should report a
				// false status under normal conditions.
				polarity?: "Positive" | "Negative"
			}]

			// version defines the desired Kubernetes version.
			// This field is meant to be optionally used by bootstrap
			// providers.
			version?: strings.MaxRunes(256) & strings.MinRunes(1)
		}
	}
}
