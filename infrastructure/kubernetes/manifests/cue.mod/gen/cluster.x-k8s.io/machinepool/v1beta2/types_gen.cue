// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f /tmp/kue/cluster-api/config/crd/bases/cluster.x-k8s.io_machinepools.yaml

package v1beta2

import (
	"strings"
	"list"
	"struct"
)

// MachinePool is the Schema for the machinepools API.
// NOTE: This CRD can only be used if the MachinePool feature gate
// is enabled.
#MachinePool: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "cluster.x-k8s.io/v1beta2"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "MachinePool"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// spec is the desired state of MachinePool.
	spec!: #MachinePoolSpec
}

// spec is the desired state of MachinePool.
#MachinePoolSpec: {
	// clusterName is the name of the Cluster this object belongs to.
	clusterName!: strings.MaxRunes(63) & strings.MinRunes(1)

	// failureDomains is the list of failure domains this MachinePool
	// should be attached to.
	failureDomains?: list.MaxItems(100) & [...strings.MaxRunes(256) & strings.MinRunes(1)]

	// providerIDList are the identification IDs of machine instances
	// provided by the provider.
	// This field must match the provider IDs as seen on the node
	// objects corresponding to a machine pool's machine instances.
	providerIDList?: list.MaxItems(10000) & [...strings.MaxRunes(512) & strings.MinRunes(1)]

	// replicas is the number of desired machines. Defaults to 1.
	// This is a pointer to distinguish between explicit zero and not
	// specified.
	replicas?: int32

	// template describes the machines that will be created.
	template!: {
		// metadata is the standard object's metadata.
		// More info:
		// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
		metadata?: struct.MinFields(1) & {
			// annotations is an unstructured key value map stored with a
			// resource that may be
			// set by external tools to store and retrieve arbitrary metadata.
			// They are not
			// queryable and should be preserved when modifying objects.
			// More info: http://kubernetes.io/docs/user-guide/annotations
			annotations?: {
				[string]: string
			}

			// labels is a map of string keys and values that can be used to
			// organize and categorize
			// (scope and select) objects. May match selectors of replication
			// controllers
			// and services.
			// More info: http://kubernetes.io/docs/user-guide/labels
			labels?: {
				[string]: string
			}
		}

		// spec is the specification of the desired behavior of the
		// machine.
		// More info:
		// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
		spec!: {
			// bootstrap is a reference to a local struct which encapsulates
			// fields to configure the Machineâ€™s bootstrapping mechanism.
			bootstrap!: {
				// configRef is a reference to a bootstrap provider-specific
				// resource
				// that holds configuration details. The reference is optional to
				// allow users/operators to specify Bootstrap.DataSecretName
				// without
				// the need of a controller.
				configRef?: {
					// apiGroup is the group of the resource being referenced.
					// apiGroup must be fully qualified domain name.
					// The corresponding version for this reference will be looked up
					// from the contract
					// labels of the corresponding CRD of the resource being
					// referenced.
					apiGroup!: strings.MaxRunes(253) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
					}

					// kind of the resource being referenced.
					// kind must consist of alphanumeric characters or '-', start with
					// an alphabetic character, and end with an alphanumeric
					// character.
					kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
						=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
					}

					// name of the resource being referenced.
					// name must consist of lower case alphanumeric characters, '-' or
					// '.', and must start and end with an alphanumeric character.
					name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
						=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
					}
				}

				// dataSecretName is the name of the secret that stores the
				// bootstrap data script.
				// If nil, the Machine should remain in the Pending state.
				dataSecretName?: strings.MaxRunes(253) & strings.MinRunes(0)
			}

			// clusterName is the name of the Cluster this object belongs to.
			clusterName!: strings.MaxRunes(63) & strings.MinRunes(1)

			// deletion contains configuration options for Machine deletion.
			deletion?: struct.MinFields(1) & {
				// nodeDeletionTimeoutSeconds defines how long the controller will
				// attempt to delete the Node that the Machine
				// hosts after the Machine is marked for deletion. A duration of 0
				// will retry deletion indefinitely.
				// Defaults to 10 seconds.
				nodeDeletionTimeoutSeconds?: int32 & >=0

				// nodeDrainTimeoutSeconds is the total amount of time that the
				// controller will spend on draining a node.
				// The default value is 0, meaning that the node can be drained
				// without any time limitations.
				// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain
				// --timeout`
				nodeDrainTimeoutSeconds?: int32 & >=0

				// nodeVolumeDetachTimeoutSeconds is the total amount of time that
				// the controller will spend on waiting for all volumes
				// to be detached. The default value is 0, meaning that the
				// volumes can be detached without any time limitations.
				nodeVolumeDetachTimeoutSeconds?: int32 & >=0
			}

			// failureDomain is the failure domain the machine will be created
			// in.
			// Must match the name of a FailureDomain from the Cluster status.
			failureDomain?: strings.MaxRunes(256) & strings.MinRunes(1)

			// infrastructureRef is a required reference to a custom resource
			// offered by an infrastructure provider.
			infrastructureRef!: {
				// apiGroup is the group of the resource being referenced.
				// apiGroup must be fully qualified domain name.
				// The corresponding version for this reference will be looked up
				// from the contract
				// labels of the corresponding CRD of the resource being
				// referenced.
				apiGroup!: strings.MaxRunes(253) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
				}

				// kind of the resource being referenced.
				// kind must consist of alphanumeric characters or '-', start with
				// an alphabetic character, and end with an alphanumeric
				// character.
				kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
				}

				// name of the resource being referenced.
				// name must consist of lower case alphanumeric characters, '-' or
				// '.', and must start and end with an alphanumeric character.
				name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
				}
			}

			// minReadySeconds is the minimum number of seconds for which a
			// Machine should be ready before considering it available.
			// Defaults to 0 (Machine will be considered available as soon as
			// the Machine is ready)
			minReadySeconds?: int32 & >=0

			// providerID is the identification ID of the machine provided by
			// the provider.
			// This field must match the provider ID as seen on the node
			// object corresponding to this machine.
			// This field is required by higher level consumers of
			// cluster-api. Example use case is cluster autoscaler
			// with cluster-api as provider. Clean-up logic in the autoscaler
			// compares machines to nodes to find out
			// machines at provider which could not get registered as
			// Kubernetes nodes. With cluster-api as a
			// generic out-of-tree provider for autoscaler, this field is
			// required by autoscaler to be
			// able to have a provider view of the list of machines. Another
			// list of nodes is queried from the k8s apiserver
			// and then a comparison is done to find out unregistered machines
			// and are marked for delete.
			// This field will be set by the actuators and consumed by higher
			// level entities like autoscaler that will
			// be interfacing with cluster-api as generic provider.
			providerID?: strings.MaxRunes(512) & strings.MinRunes(1)

			// readinessGates specifies additional conditions to include when
			// evaluating Machine Ready condition.
			//
			// This field can be used e.g. by Cluster API control plane
			// providers to extend the semantic of the
			// Ready condition for the Machine they control, like the kubeadm
			// control provider adding ReadinessGates
			// for the APIServerPodHealthy, SchedulerPodHealthy conditions,
			// etc.
			//
			// Another example are external controllers, e.g. responsible to
			// install special software/hardware on the Machines;
			// they can include the status of those components with a new
			// condition and add this condition to ReadinessGates.
			//
			// NOTE: In case readinessGates conditions start with the
			// APIServer, ControllerManager, Scheduler prefix, and all those
			// readiness gates condition are reporting the same message, when
			// computing the Machine's Ready condition those
			// readinessGates will be replaced by a single entry reporting
			// "Control plane components: " + message.
			// This helps to improve readability of conditions bubbling up to
			// the Machine's owner resource / to the Cluster).
			readinessGates?: list.MaxItems(32) & [...{
				// conditionType refers to a condition with matching type in the
				// Machine's condition list.
				// If the conditions doesn't exist, it will be treated as unknown.
				// Note: Both Cluster API conditions or conditions added by 3rd
				// party controllers can be used as readiness gates.
				conditionType!: strings.MaxRunes(316) & strings.MinRunes(1) & {
					=~"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
				}

				// polarity of the conditionType specified in this readinessGate.
				// Valid values are Positive, Negative and omitted.
				// When omitted, the default behaviour will be Positive.
				// A positive polarity means that the condition should report a
				// true status under normal conditions.
				// A negative polarity means that the condition should report a
				// false status under normal conditions.
				polarity?: "Positive" | "Negative"
			}] & [_, ...]

			// version defines the desired Kubernetes version.
			// This field is meant to be optionally used by bootstrap
			// providers.
			version?: strings.MaxRunes(256) & strings.MinRunes(1)
		}
	}
}
