// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f /tmp/kue/cluster-api/config/crd/bases/cluster.x-k8s.io_clusters.yaml

package v1beta2

import (
	"strings"
	"struct"
	"list"
)

// Cluster is the Schema for the clusters API.
#Cluster: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "cluster.x-k8s.io/v1beta2"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "Cluster"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// spec is the desired state of Cluster.
	spec!: #ClusterSpec
}

// spec is the desired state of Cluster.
#ClusterSpec: struct.MinFields(1) & {
	// availabilityGates specifies additional conditions to include
	// when evaluating Cluster Available condition.
	//
	// If this field is not defined and the Cluster implements a
	// managed topology, availabilityGates
	// from the corresponding ClusterClass will be used, if any.
	availabilityGates?: list.MaxItems(32) & [...{
		// conditionType refers to a condition with matching type in the
		// Cluster's condition list.
		// If the conditions doesn't exist, it will be treated as unknown.
		// Note: Both Cluster API conditions or conditions added by 3rd
		// party controllers can be used as availability gates.
		conditionType!: strings.MaxRunes(316) & strings.MinRunes(1) & {
			=~"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
		}

		// polarity of the conditionType specified in this
		// availabilityGate.
		// Valid values are Positive, Negative and omitted.
		// When omitted, the default behaviour will be Positive.
		// A positive polarity means that the condition should report a
		// true status under normal conditions.
		// A negative polarity means that the condition should report a
		// false status under normal conditions.
		polarity?: "Positive" | "Negative"
	}] & [_, ...]

	// clusterNetwork represents the cluster network configuration.
	clusterNetwork?: struct.MinFields(1) & {
		// apiServerPort specifies the port the API Server should bind to.
		// Defaults to 6443.
		apiServerPort?: uint16 & >=1
		pods?: {
			// cidrBlocks is a list of CIDR blocks.
			cidrBlocks!: list.MaxItems(100) & [...strings.MaxRunes(43) & strings.MinRunes(1)] & [_, ...]
		}

		// serviceDomain is the domain name for services.
		serviceDomain?: strings.MaxRunes(253) & strings.MinRunes(1)
		services?: {
			// cidrBlocks is a list of CIDR blocks.
			cidrBlocks!: list.MaxItems(100) & [...strings.MaxRunes(43) & strings.MinRunes(1)] & [_, ...]
		}
	}

	// controlPlaneEndpoint represents the endpoint used to
	// communicate with the control plane.
	controlPlaneEndpoint?: struct.MinFields(1) & {
		// host is the hostname on which the API server is serving.
		host?: strings.MaxRunes(512) & strings.MinRunes(1)

		// port is the port on which the API server is serving.
		port?: uint16 & >=1
	}

	// controlPlaneRef is an optional reference to a provider-specific
	// resource that holds
	// the details for provisioning the Control Plane for a Cluster.
	controlPlaneRef?: {
		// apiGroup is the group of the resource being referenced.
		// apiGroup must be fully qualified domain name.
		// The corresponding version for this reference will be looked up
		// from the contract
		// labels of the corresponding CRD of the resource being
		// referenced.
		apiGroup!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// kind of the resource being referenced.
		// kind must consist of alphanumeric characters or '-', start with
		// an alphabetic character, and end with an alphanumeric
		// character.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// name of the resource being referenced.
		// name must consist of lower case alphanumeric characters, '-' or
		// '.', and must start and end with an alphanumeric character.
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}

	// infrastructureRef is a reference to a provider-specific
	// resource that holds the details
	// for provisioning infrastructure for a cluster in said provider.
	infrastructureRef?: {
		// apiGroup is the group of the resource being referenced.
		// apiGroup must be fully qualified domain name.
		// The corresponding version for this reference will be looked up
		// from the contract
		// labels of the corresponding CRD of the resource being
		// referenced.
		apiGroup!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// kind of the resource being referenced.
		// kind must consist of alphanumeric characters or '-', start with
		// an alphabetic character, and end with an alphanumeric
		// character.
		kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// name of the resource being referenced.
		// name must consist of lower case alphanumeric characters, '-' or
		// '.', and must start and end with an alphanumeric character.
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}

	// paused can be used to prevent controllers from processing the
	// Cluster and all its associated objects.
	paused?: bool

	// topology encapsulates the topology for the cluster.
	// NOTE: It is required to enable the ClusterTopology
	// feature gate flag to activate managed topologies support;
	// this feature is highly experimental, and parts of it might
	// still be not implemented.
	topology?: {
		// classRef is the ref to the ClusterClass that should be used for
		// the topology.
		classRef!: {
			// name is the name of the ClusterClass that should be used for
			// the topology.
			// name must be a valid ClusterClass name and because of that be
			// at most 253 characters in length
			// and it must consist only of lower case alphanumeric characters,
			// hyphens (-) and periods (.), and must start
			// and end with an alphanumeric character.
			name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
			}

			// namespace is the namespace of the ClusterClass that should be
			// used for the topology.
			// If namespace is empty or not set, it is defaulted to the
			// namespace of the Cluster object.
			// namespace must be a valid namespace name and because of that be
			// at most 63 characters in length
			// and it must consist only of lower case alphanumeric characters
			// or hyphens (-), and must start
			// and end with an alphanumeric character.
			namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
			}
		}

		// controlPlane describes the cluster control plane.
		controlPlane?: struct.MinFields(1) & {
			// deletion contains configuration options for Machine deletion.
			deletion?: struct.MinFields(1) & {
				// nodeDeletionTimeoutSeconds defines how long the controller will
				// attempt to delete the Node that the Machine
				// hosts after the Machine is marked for deletion. A duration of 0
				// will retry deletion indefinitely.
				// Defaults to 10 seconds.
				nodeDeletionTimeoutSeconds?: int32 & >=0

				// nodeDrainTimeoutSeconds is the total amount of time that the
				// controller will spend on draining a node.
				// The default value is 0, meaning that the node can be drained
				// without any time limitations.
				// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain
				// --timeout`
				nodeDrainTimeoutSeconds?: int32 & >=0

				// nodeVolumeDetachTimeoutSeconds is the total amount of time that
				// the controller will spend on waiting for all volumes
				// to be detached. The default value is 0, meaning that the
				// volumes can be detached without any time limitations.
				nodeVolumeDetachTimeoutSeconds?: int32 & >=0
			}

			// healthCheck allows to enable, disable and override control
			// plane health check
			// configuration from the ClusterClass for this control plane.
			healthCheck?: struct.MinFields(1) & {
				// checks are the checks that are used to evaluate if a Machine is
				// healthy.
				//
				// If one of checks and remediation fields are set, the system
				// assumes that an healthCheck override is defined,
				// and as a consequence the checks and remediation fields from
				// Cluster will be used instead of the
				// corresponding fields in ClusterClass.
				//
				// Independent of this configuration the MachineHealthCheck
				// controller will always
				// flag Machines with `cluster.x-k8s.io/remediate-machine`
				// annotation and
				// Machines with deleted Nodes as unhealthy.
				//
				// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
				// is defaulted to 10 minutes and evaluated accordingly.
				checks?: struct.MinFields(1) & {
					// nodeStartupTimeoutSeconds allows to set the maximum time for
					// MachineHealthCheck
					// to consider a Machine unhealthy if a corresponding Node isn't
					// associated
					// through a `Spec.ProviderID` field.
					//
					// The duration set in this field is compared to the greatest of:
					// - Cluster's infrastructure ready condition timestamp (if and
					// when available)
					// - Control Plane's initialized condition timestamp (if and when
					// available)
					// - Machine's infrastructure ready condition timestamp (if and
					// when available)
					// - Machine's metadata creation timestamp
					//
					// Defaults to 10 minutes.
					// If you wish to disable this feature, set the value explicitly
					// to 0.
					nodeStartupTimeoutSeconds?: int32 & >=0

					// unhealthyNodeConditions contains a list of conditions that
					// determine
					// whether a node is considered unhealthy. The conditions are
					// combined in a
					// logical OR, i.e. if any of the conditions is met, the node is
					// unhealthy.
					unhealthyNodeConditions?: list.MaxItems(100) & [...{
						// status of the condition, one of True, False, Unknown.
						status!: strings.MinRunes(1)

						// timeoutSeconds is the duration that a node must be in a given
						// status for,
						// after which the node is considered unhealthy.
						// For example, with a value of "1h", the node must match the
						// status
						// for at least 1 hour before being considered unhealthy.
						timeoutSeconds!: int32 & >=0

						// type of Node condition
						type!: strings.MinRunes(1)
					}] & [_, ...]
				}

				// enabled controls if a MachineHealthCheck should be created for
				// the target machines.
				//
				// If false: No MachineHealthCheck will be created.
				//
				// If not set(default): A MachineHealthCheck will be created if it
				// is defined here or
				// in the associated ClusterClass. If no MachineHealthCheck is
				// defined then none will be created.
				//
				// If true: A MachineHealthCheck is guaranteed to be created.
				// Cluster validation will
				// block if `enable` is true and no MachineHealthCheck definition
				// is available.
				enabled?: bool

				// remediation configures if and how remediations are triggered if
				// a Machine is unhealthy.
				//
				// If one of checks and remediation fields are set, the system
				// assumes that an healthCheck override is defined,
				// and as a consequence the checks and remediation fields from
				// cluster will be used instead of the
				// corresponding fields in ClusterClass.
				//
				// If an health check override is defined and remediation or
				// remediation.triggerIf is not set,
				// remediation will always be triggered for unhealthy Machines.
				//
				// If an health check override is defined and remediation or
				// remediation.templateRef is not set,
				// the OwnerRemediated condition will be set on unhealthy Machines
				// to trigger remediation via
				// the owner of the Machines, for example a MachineSet or a
				// KubeadmControlPlane.
				remediation?: struct.MinFields(1) & {
					// templateRef is a reference to a remediation template
					// provided by an infrastructure provider.
					//
					// This field is completely optional, when filled, the
					// MachineHealthCheck controller
					// creates a new object from the template referenced and hands off
					// remediation of the machine to
					// a controller that lives outside of Cluster API.
					templateRef?: {
						// apiVersion of the remediation template.
						// apiVersion must be fully qualified domain name followed by /
						// and a version.
						// NOTE: This field must be kept in sync with the APIVersion of
						// the remediation template.
						apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
							=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
						}

						// kind of the remediation template.
						// kind must consist of alphanumeric characters or '-', start with
						// an alphabetic character, and end with an alphanumeric
						// character.
						kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
							=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
						}

						// name of the remediation template.
						// name must consist of lower case alphanumeric characters, '-' or
						// '.', and must start and end with an alphanumeric character.
						name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
							=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
						}
					}

					// triggerIf configures if remediations are triggered.
					// If this field is not set, remediations are always triggered.
					triggerIf?: struct.MinFields(1) & {
						// unhealthyInRange specifies that remediations are only triggered
						// if the number of
						// unhealthy Machines is in the configured range.
						// Takes precedence over unhealthyLessThanOrEqualTo.
						// Eg. "[3-5]" - This means that remediation will be allowed only
						// when:
						// (a) there are at least 3 unhealthy Machines (and)
						// (b) there are at most 5 unhealthy Machines
						unhealthyInRange?: strings.MaxRunes(32) & strings.MinRunes(1) & {
							=~"^\\[[0-9]+-[0-9]+\\]$"
						}

						// unhealthyLessThanOrEqualTo specifies that remediations are only
						// triggered if the number of
						// unhealthy Machines is less than or equal to the configured
						// value.
						// unhealthyInRange takes precedence if set.
						unhealthyLessThanOrEqualTo?: matchN(>=1, [int, string])
					}
				}
			}

			// metadata is the metadata applied to the ControlPlane and the
			// Machines of the ControlPlane
			// if the ControlPlaneTemplate referenced by the ClusterClass is
			// machine based. If not, it
			// is applied only to the ControlPlane.
			// At runtime this metadata is merged with the corresponding
			// metadata from the ClusterClass.
			metadata?: struct.MinFields(1) & {
				// annotations is an unstructured key value map stored with a
				// resource that may be
				// set by external tools to store and retrieve arbitrary metadata.
				// They are not
				// queryable and should be preserved when modifying objects.
				// More info: http://kubernetes.io/docs/user-guide/annotations
				annotations?: {
					[string]: string
				}

				// labels is a map of string keys and values that can be used to
				// organize and categorize
				// (scope and select) objects. May match selectors of replication
				// controllers
				// and services.
				// More info: http://kubernetes.io/docs/user-guide/labels
				labels?: {
					[string]: string
				}
			}

			// readinessGates specifies additional conditions to include when
			// evaluating Machine Ready condition.
			//
			// This field can be used e.g. to instruct the machine controller
			// to include in the computation for Machine's ready
			// computation a condition, managed by an external controllers,
			// reporting the status of special software/hardware installed on
			// the Machine.
			//
			// If this field is not defined, readinessGates from the
			// corresponding ControlPlaneClass will be used, if any.
			//
			// NOTE: Specific control plane provider implementations might
			// automatically extend the list of readinessGates;
			// e.g. the kubeadm control provider adds ReadinessGates for the
			// APIServerPodHealthy, SchedulerPodHealthy conditions, etc.
			readinessGates?: list.MaxItems(32) & [...{
				// conditionType refers to a condition with matching type in the
				// Machine's condition list.
				// If the conditions doesn't exist, it will be treated as unknown.
				// Note: Both Cluster API conditions or conditions added by 3rd
				// party controllers can be used as readiness gates.
				conditionType!: strings.MaxRunes(316) & strings.MinRunes(1) & {
					=~"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
				}

				// polarity of the conditionType specified in this readinessGate.
				// Valid values are Positive, Negative and omitted.
				// When omitted, the default behaviour will be Positive.
				// A positive polarity means that the condition should report a
				// true status under normal conditions.
				// A negative polarity means that the condition should report a
				// false status under normal conditions.
				polarity?: "Positive" | "Negative"
			}] & [_, ...]

			// replicas is the number of control plane nodes.
			// If the value is not set, the ControlPlane object is created
			// without the number of Replicas
			// and it's assumed that the control plane controller does not
			// implement support for this field.
			// When specified against a control plane provider that lacks
			// support for this field, this value will be ignored.
			replicas?: int32

			// variables can be used to customize the ControlPlane through
			// patches.
			variables?: struct.MinFields(1) & {
				// overrides can be used to override Cluster level variables.
				overrides?: list.MaxItems(1000) & [...{
					// name of the variable.
					name!: strings.MaxRunes(256) & strings.MinRunes(1)

					// value of the variable.
					// Note: the value will be validated against the schema of the
					// corresponding ClusterClassVariable
					// from the ClusterClass.
					// Note: We have to use apiextensionsv1.JSON instead of a custom
					// JSON type, because controller-tools has a
					// hard-coded schema for apiextensionsv1.JSON which cannot be
					// produced by another type via controller-tools,
					// i.e. it is not possible to have no type field.
					// Ref:
					// https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
					value!: _
				}] & [_, ...]
			}
		}

		// variables can be used to customize the Cluster through
		// patches. They must comply to the corresponding
		// VariableClasses defined in the ClusterClass.
		variables?: list.MaxItems(1000) & [...{
			// name of the variable.
			name!: strings.MaxRunes(256) & strings.MinRunes(1)

			// value of the variable.
			// Note: the value will be validated against the schema of the
			// corresponding ClusterClassVariable
			// from the ClusterClass.
			// Note: We have to use apiextensionsv1.JSON instead of a custom
			// JSON type, because controller-tools has a
			// hard-coded schema for apiextensionsv1.JSON which cannot be
			// produced by another type via controller-tools,
			// i.e. it is not possible to have no type field.
			// Ref:
			// https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
			value!: _
		}] & [_, ...]

		// version is the Kubernetes version of the cluster.
		version!: strings.MaxRunes(256) & strings.MinRunes(1)

		// workers encapsulates the different constructs that form the
		// worker nodes
		// for the cluster.
		workers?: struct.MinFields(1) & {
			// machineDeployments is a list of machine deployments in the
			// cluster.
			machineDeployments?: list.MaxItems(2000) & [...{
				// class is the name of the MachineDeploymentClass used to create
				// the set of worker nodes.
				// This should match one of the deployment classes defined in the
				// ClusterClass object
				// mentioned in the `Cluster.Spec.Class` field.
				class!: strings.MaxRunes(256) & strings.MinRunes(1)

				// deletion contains configuration options for Machine deletion.
				deletion?: struct.MinFields(1) & {
					// nodeDeletionTimeoutSeconds defines how long the controller will
					// attempt to delete the Node that the Machine
					// hosts after the Machine is marked for deletion. A duration of 0
					// will retry deletion indefinitely.
					// Defaults to 10 seconds.
					nodeDeletionTimeoutSeconds?: int32 & >=0

					// nodeDrainTimeoutSeconds is the total amount of time that the
					// controller will spend on draining a node.
					// The default value is 0, meaning that the node can be drained
					// without any time limitations.
					// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain
					// --timeout`
					nodeDrainTimeoutSeconds?: int32 & >=0

					// nodeVolumeDetachTimeoutSeconds is the total amount of time that
					// the controller will spend on waiting for all volumes
					// to be detached. The default value is 0, meaning that the
					// volumes can be detached without any time limitations.
					nodeVolumeDetachTimeoutSeconds?: int32 & >=0

					// order defines the order in which Machines are deleted when
					// downscaling.
					// Defaults to "Random". Valid values are "Random, "Newest",
					// "Oldest"
					order?: "Random" | "Newest" | "Oldest"
				}

				// failureDomain is the failure domain the machines will be
				// created in.
				// Must match a key in the FailureDomains map stored on the
				// cluster object.
				failureDomain?: strings.MaxRunes(256) & strings.MinRunes(1)

				// healthCheck allows to enable, disable and override
				// MachineDeployment health check
				// configuration from the ClusterClass for this MachineDeployment.
				healthCheck?: struct.MinFields(1) & {
					// checks are the checks that are used to evaluate if a Machine is
					// healthy.
					//
					// If one of checks and remediation fields are set, the system
					// assumes that an healthCheck override is defined,
					// and as a consequence the checks and remediation fields from
					// Cluster will be used instead of the
					// corresponding fields in ClusterClass.
					//
					// Independent of this configuration the MachineHealthCheck
					// controller will always
					// flag Machines with `cluster.x-k8s.io/remediate-machine`
					// annotation and
					// Machines with deleted Nodes as unhealthy.
					//
					// Furthermore, if checks.nodeStartupTimeoutSeconds is not set it
					// is defaulted to 10 minutes and evaluated accordingly.
					checks?: struct.MinFields(1) & {
						// nodeStartupTimeoutSeconds allows to set the maximum time for
						// MachineHealthCheck
						// to consider a Machine unhealthy if a corresponding Node isn't
						// associated
						// through a `Spec.ProviderID` field.
						//
						// The duration set in this field is compared to the greatest of:
						// - Cluster's infrastructure ready condition timestamp (if and
						// when available)
						// - Control Plane's initialized condition timestamp (if and when
						// available)
						// - Machine's infrastructure ready condition timestamp (if and
						// when available)
						// - Machine's metadata creation timestamp
						//
						// Defaults to 10 minutes.
						// If you wish to disable this feature, set the value explicitly
						// to 0.
						nodeStartupTimeoutSeconds?: int32 & >=0

						// unhealthyNodeConditions contains a list of conditions that
						// determine
						// whether a node is considered unhealthy. The conditions are
						// combined in a
						// logical OR, i.e. if any of the conditions is met, the node is
						// unhealthy.
						unhealthyNodeConditions?: list.MaxItems(100) & [...{
							// status of the condition, one of True, False, Unknown.
							status!: strings.MinRunes(1)

							// timeoutSeconds is the duration that a node must be in a given
							// status for,
							// after which the node is considered unhealthy.
							// For example, with a value of "1h", the node must match the
							// status
							// for at least 1 hour before being considered unhealthy.
							timeoutSeconds!: int32 & >=0

							// type of Node condition
							type!: strings.MinRunes(1)
						}] & [_, ...]
					}

					// enabled controls if a MachineHealthCheck should be created for
					// the target machines.
					//
					// If false: No MachineHealthCheck will be created.
					//
					// If not set(default): A MachineHealthCheck will be created if it
					// is defined here or
					// in the associated ClusterClass. If no MachineHealthCheck is
					// defined then none will be created.
					//
					// If true: A MachineHealthCheck is guaranteed to be created.
					// Cluster validation will
					// block if `enable` is true and no MachineHealthCheck definition
					// is available.
					enabled?: bool

					// remediation configures if and how remediations are triggered if
					// a Machine is unhealthy.
					//
					// If one of checks and remediation fields are set, the system
					// assumes that an healthCheck override is defined,
					// and as a consequence the checks and remediation fields from
					// cluster will be used instead of the
					// corresponding fields in ClusterClass.
					//
					// If an health check override is defined and remediation or
					// remediation.triggerIf is not set,
					// remediation will always be triggered for unhealthy Machines.
					//
					// If an health check override is defined and remediation or
					// remediation.templateRef is not set,
					// the OwnerRemediated condition will be set on unhealthy Machines
					// to trigger remediation via
					// the owner of the Machines, for example a MachineSet or a
					// KubeadmControlPlane.
					remediation?: struct.MinFields(1) & {
						// maxInFlight determines how many in flight remediations should
						// happen at the same time.
						//
						// Remediation only happens on the MachineSet with the most
						// current revision, while
						// older MachineSets (usually present during rollout operations)
						// aren't allowed to remediate.
						//
						// Note: In general (independent of remediations), unhealthy
						// machines are always
						// prioritized during scale down operations over healthy ones.
						//
						// MaxInFlight can be set to a fixed number or a percentage.
						// Example: when this is set to 20%, the MachineSet controller
						// deletes at most 20% of
						// the desired replicas.
						//
						// If not set, remediation is limited to all machines (bounded by
						// replicas)
						// under the active MachineSet's management.
						maxInFlight?: matchN(>=1, [int, string])

						// templateRef is a reference to a remediation template
						// provided by an infrastructure provider.
						//
						// This field is completely optional, when filled, the
						// MachineHealthCheck controller
						// creates a new object from the template referenced and hands off
						// remediation of the machine to
						// a controller that lives outside of Cluster API.
						templateRef?: {
							// apiVersion of the remediation template.
							// apiVersion must be fully qualified domain name followed by /
							// and a version.
							// NOTE: This field must be kept in sync with the APIVersion of
							// the remediation template.
							apiVersion!: strings.MaxRunes(317) & strings.MinRunes(1) & {
								=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\\/[a-z]([-a-z0-9]*[a-z0-9])?$"
							}

							// kind of the remediation template.
							// kind must consist of alphanumeric characters or '-', start with
							// an alphabetic character, and end with an alphanumeric
							// character.
							kind!: strings.MaxRunes(63) & strings.MinRunes(1) & {
								=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
							}

							// name of the remediation template.
							// name must consist of lower case alphanumeric characters, '-' or
							// '.', and must start and end with an alphanumeric character.
							name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
								=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
							}
						}

						// triggerIf configures if remediations are triggered.
						// If this field is not set, remediations are always triggered.
						triggerIf?: struct.MinFields(1) & {
							// unhealthyInRange specifies that remediations are only triggered
							// if the number of
							// unhealthy Machines is in the configured range.
							// Takes precedence over unhealthyLessThanOrEqualTo.
							// Eg. "[3-5]" - This means that remediation will be allowed only
							// when:
							// (a) there are at least 3 unhealthy Machines (and)
							// (b) there are at most 5 unhealthy Machines
							unhealthyInRange?: strings.MaxRunes(32) & strings.MinRunes(1) & {
								=~"^\\[[0-9]+-[0-9]+\\]$"
							}

							// unhealthyLessThanOrEqualTo specifies that remediations are only
							// triggered if the number of
							// unhealthy Machines is less than or equal to the configured
							// value.
							// unhealthyInRange takes precedence if set.
							unhealthyLessThanOrEqualTo?: matchN(>=1, [int, string])
						}
					}
				}

				// metadata is the metadata applied to the MachineDeployment and
				// the machines of the MachineDeployment.
				// At runtime this metadata is merged with the corresponding
				// metadata from the ClusterClass.
				metadata?: struct.MinFields(1) & {
					// annotations is an unstructured key value map stored with a
					// resource that may be
					// set by external tools to store and retrieve arbitrary metadata.
					// They are not
					// queryable and should be preserved when modifying objects.
					// More info: http://kubernetes.io/docs/user-guide/annotations
					annotations?: {
						[string]: string
					}

					// labels is a map of string keys and values that can be used to
					// organize and categorize
					// (scope and select) objects. May match selectors of replication
					// controllers
					// and services.
					// More info: http://kubernetes.io/docs/user-guide/labels
					labels?: {
						[string]: string
					}
				}

				// minReadySeconds is the minimum number of seconds for which a
				// newly created machine should
				// be ready.
				// Defaults to 0 (machine will be considered available as soon as
				// it
				// is ready)
				minReadySeconds?: int32 & >=0

				// name is the unique identifier for this
				// MachineDeploymentTopology.
				// The value is used with other unique identifiers to create a
				// MachineDeployment's Name
				// (e.g. cluster's name, etc). In case the name is greater than
				// the allowed maximum length,
				// the values are hashed together.
				name!: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
				}

				// readinessGates specifies additional conditions to include when
				// evaluating Machine Ready condition.
				//
				// This field can be used e.g. to instruct the machine controller
				// to include in the computation for Machine's ready
				// computation a condition, managed by an external controllers,
				// reporting the status of special software/hardware installed on
				// the Machine.
				//
				// If this field is not defined, readinessGates from the
				// corresponding MachineDeploymentClass will be used, if any.
				readinessGates?: list.MaxItems(32) & [...{
					// conditionType refers to a condition with matching type in the
					// Machine's condition list.
					// If the conditions doesn't exist, it will be treated as unknown.
					// Note: Both Cluster API conditions or conditions added by 3rd
					// party controllers can be used as readiness gates.
					conditionType!: strings.MaxRunes(316) & strings.MinRunes(1) & {
						=~"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
					}

					// polarity of the conditionType specified in this readinessGate.
					// Valid values are Positive, Negative and omitted.
					// When omitted, the default behaviour will be Positive.
					// A positive polarity means that the condition should report a
					// true status under normal conditions.
					// A negative polarity means that the condition should report a
					// false status under normal conditions.
					polarity?: "Positive" | "Negative"
				}] & [_, ...]

				// replicas is the number of worker nodes belonging to this set.
				// If the value is nil, the MachineDeployment is created without
				// the number of Replicas (defaulting to 1)
				// and it's assumed that an external entity (like cluster
				// autoscaler) is responsible for the management
				// of this value.
				replicas?: int32

				// rollout allows you to configure the behaviour of rolling
				// updates to the MachineDeployment Machines.
				// It allows you to define the strategy used during rolling
				// replacements.
				rollout?: struct.MinFields(1) & {
					// strategy specifies how to roll out control plane Machines.
					strategy?: struct.MinFields(1) & {
						// rollingUpdate is the rolling update config params. Present only
						// if
						// type = RollingUpdate.
						rollingUpdate?: struct.MinFields(1) & {
							// maxSurge is the maximum number of machines that can be
							// scheduled above the
							// desired number of machines.
							// Value can be an absolute number (ex: 5) or a percentage of
							// desired machines (ex: 10%).
							// This can not be 0 if MaxUnavailable is 0.
							// Absolute number is calculated from percentage by rounding up.
							// Defaults to 1.
							// Example: when this is set to 30%, the new MachineSet can be
							// scaled
							// up immediately when the rolling update starts, such that the
							// total
							// number of old and new machines do not exceed 130% of desired
							// machines. Once old machines have been killed, new MachineSet
							// can
							// be scaled up further, ensuring that total number of machines
							// running
							// at any time during the update is at most 130% of desired
							// machines.
							maxSurge?: matchN(>=1, [int, string])

							// maxUnavailable is the maximum number of machines that can be
							// unavailable during the update.
							// Value can be an absolute number (ex: 5) or a percentage of
							// desired
							// machines (ex: 10%).
							// Absolute number is calculated from percentage by rounding down.
							// This can not be 0 if MaxSurge is 0.
							// Defaults to 0.
							// Example: when this is set to 30%, the old MachineSet can be
							// scaled
							// down to 70% of desired machines immediately when the rolling
							// update
							// starts. Once new machines are ready, old MachineSet can be
							// scaled
							// down further, followed by scaling up the new MachineSet,
							// ensuring
							// that the total number of machines available at all times
							// during the update is at least 70% of desired machines.
							maxUnavailable?: matchN(>=1, [int, string])
						}

						// type of rollout. Allowed values are RollingUpdate and OnDelete.
						// Default is RollingUpdate.
						type!: "RollingUpdate" | "OnDelete"
					}
				}

				// variables can be used to customize the MachineDeployment
				// through patches.
				variables?: struct.MinFields(1) & {
					// overrides can be used to override Cluster level variables.
					overrides?: list.MaxItems(1000) & [...{
						// name of the variable.
						name!: strings.MaxRunes(256) & strings.MinRunes(1)

						// value of the variable.
						// Note: the value will be validated against the schema of the
						// corresponding ClusterClassVariable
						// from the ClusterClass.
						// Note: We have to use apiextensionsv1.JSON instead of a custom
						// JSON type, because controller-tools has a
						// hard-coded schema for apiextensionsv1.JSON which cannot be
						// produced by another type via controller-tools,
						// i.e. it is not possible to have no type field.
						// Ref:
						// https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
						value!: _
					}] & [_, ...]
				}
			}] & [_, ...]

			// machinePools is a list of machine pools in the cluster.
			machinePools?: list.MaxItems(2000) & [...{
				// class is the name of the MachinePoolClass used to create the
				// pool of worker nodes.
				// This should match one of the deployment classes defined in the
				// ClusterClass object
				// mentioned in the `Cluster.Spec.Class` field.
				class!: strings.MaxRunes(256) & strings.MinRunes(1)

				// deletion contains configuration options for Machine deletion.
				deletion?: struct.MinFields(1) & {
					// nodeDeletionTimeoutSeconds defines how long the controller will
					// attempt to delete the Node that the MachinePool
					// hosts after the MachinePool is marked for deletion. A duration
					// of 0 will retry deletion indefinitely.
					// Defaults to 10 seconds.
					nodeDeletionTimeoutSeconds?: int32 & >=0

					// nodeDrainTimeoutSeconds is the total amount of time that the
					// controller will spend on draining a node.
					// The default value is 0, meaning that the node can be drained
					// without any time limitations.
					// NOTE: nodeDrainTimeoutSeconds is different from `kubectl drain
					// --timeout`
					nodeDrainTimeoutSeconds?: int32 & >=0

					// nodeVolumeDetachTimeoutSeconds is the total amount of time that
					// the controller will spend on waiting for all volumes
					// to be detached. The default value is 0, meaning that the
					// volumes can be detached without any time limitations.
					nodeVolumeDetachTimeoutSeconds?: int32 & >=0
				}

				// failureDomains is the list of failure domains the machine pool
				// will be created in.
				// Must match a key in the FailureDomains map stored on the
				// cluster object.
				failureDomains?: list.MaxItems(100) & [...strings.MaxRunes(256) & strings.MinRunes(1)] & [_, ...]

				// metadata is the metadata applied to the MachinePool.
				// At runtime this metadata is merged with the corresponding
				// metadata from the ClusterClass.
				metadata?: struct.MinFields(1) & {
					// annotations is an unstructured key value map stored with a
					// resource that may be
					// set by external tools to store and retrieve arbitrary metadata.
					// They are not
					// queryable and should be preserved when modifying objects.
					// More info: http://kubernetes.io/docs/user-guide/annotations
					annotations?: {
						[string]: string
					}

					// labels is a map of string keys and values that can be used to
					// organize and categorize
					// (scope and select) objects. May match selectors of replication
					// controllers
					// and services.
					// More info: http://kubernetes.io/docs/user-guide/labels
					labels?: {
						[string]: string
					}
				}

				// minReadySeconds is the minimum number of seconds for which a
				// newly created machine pool should
				// be ready.
				// Defaults to 0 (machine will be considered available as soon as
				// it
				// is ready)
				minReadySeconds?: int32 & >=0

				// name is the unique identifier for this MachinePoolTopology.
				// The value is used with other unique identifiers to create a
				// MachinePool's Name
				// (e.g. cluster's name, etc). In case the name is greater than
				// the allowed maximum length,
				// the values are hashed together.
				name!: strings.MaxRunes(63) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
				}

				// replicas is the number of nodes belonging to this pool.
				// If the value is nil, the MachinePool is created without the
				// number of Replicas (defaulting to 1)
				// and it's assumed that an external entity (like cluster
				// autoscaler) is responsible for the management
				// of this value.
				replicas?: int32

				// variables can be used to customize the MachinePool through
				// patches.
				variables?: struct.MinFields(1) & {
					// overrides can be used to override Cluster level variables.
					overrides?: list.MaxItems(1000) & [...{
						// name of the variable.
						name!: strings.MaxRunes(256) & strings.MinRunes(1)

						// value of the variable.
						// Note: the value will be validated against the schema of the
						// corresponding ClusterClassVariable
						// from the ClusterClass.
						// Note: We have to use apiextensionsv1.JSON instead of a custom
						// JSON type, because controller-tools has a
						// hard-coded schema for apiextensionsv1.JSON which cannot be
						// produced by another type via controller-tools,
						// i.e. it is not possible to have no type field.
						// Ref:
						// https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
						value!: _
					}] & [_, ...]
				}
			}] & [_, ...]
		}
	}
}
